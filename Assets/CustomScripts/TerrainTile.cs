//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using UnityEngine;

namespace AssemblyCSharp
{
	public class TerrainTile
	{
		public static LibNoise.ModuleBase module;
	
		public static int heightMapResolution;
		public static int alphaMapResolution;
		public static int tileSize;
		public static int ceilingHeight;
		
		public static int noiseScale;
		public static int seed;
		
		public static Vector3 dataSize;
		public static float size;
	
		public string tileName;
		public Vector2 position;
		public int dist;
		
		public GameObject terrain;
		public float[,] heightMap;
		public float[,,] splatData;
		
		public GameObject water;
		
		public static GameObject waterPrefab;
		
		private static double minAlt = 1.0;
		private static double maxAlt = 0.0;
		
		private readonly int alphaLayers = 4;
		
		public static float sea_level = 0.3f;
		
		private float minAltitude = 1.0f;
		
		public bool isLoading = false;
		
		public bool hasWater
		{
			get
			{
				if(minAltitude < sea_level)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool IsGenerated
		{
			get
			{
				if(heightMap != null && splatData != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool isLoaded
		{
			get
			{
				if(terrain != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public TerrainTile(Vector2 position, string tileName, int dist, float[,] heightMap, float[,,] splatData, GameObject terrain)
		{
			this.position = position;
			this.terrain = terrain;
			this.dist = dist;
			this.heightMap = heightMap;
			this.tileName = tileName;
			this.splatData = splatData;
		}
		
		public void setHeight(int x, int y, float value)
		{
			if(heightMap != null && (x < heightMapResolution && x >= 0) && (y < heightMapResolution && y >= 0))
			{
				heightMap[x,y] = value;
				
				Terrain terr = (Terrain)terrain.GetComponent(typeof(Terrain));
				terr.terrainData.SetHeights(0,0,heightMap);
			}
		}
		
		public float getHeight(int x, int y)
		{
			if(heightMap != null)
			{
				return heightMap[x,y];
			}
			else
			{
				return 0f;
			}
		}
		
		public float getSteepness(int x, int y)
		{
			float maxSteepness = 0;
			
			float centralHeight = getHeight(x,y);
			
			//Loop through all the neighboring heights
			for(int xI = -1; xI <= 1; xI++)
			{
				for(int yI = -1; yI <= 1; yI++)
				{
					int sampleX = x + xI;
					int sampleY = y + yI;
					//Don't attempt to sample if we're outside the bounds of the array.
					if(sampleX >= 0 && sampleX <= Mathf.Sqrt(heightMap.Length) - 1)
					{
						if(sampleY >= 0 && sampleY <= Mathf.Sqrt(heightMap.Length) - 1)
						{
							float steepness = Mathf.Abs(centralHeight - getHeight(sampleX, sampleY));
							if(maxSteepness < steepness)
							{
								maxSteepness = steepness;
							}
						}
					}
				}
			}
			
			return maxSteepness;
		}
		
		public void unload()
		{
			GameObject.DestroyImmediate(terrain);
			if(water != null)
			{
				GameObject.DestroyImmediate(water);
			}
		}
		
		public void load()
		{
			GameObject newTile = new GameObject();
			
			newTile.name = tileName;
			
			//newTile.transform.position = new Vector3 (((int)position.x - 250) * (size), 0, ((int)position.y - 250) * (size));
			newTile.transform.position = new Vector3 (((int)position.x) * (size), 0, ((int)position.y) * (size));
			
			
			newTile.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)newTile.GetComponent(typeof(Terrain));
			
			newTile.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)newTile.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
						
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = heightMapResolution;
			terrainData.size = dataSize;
			
			terrainData.alphamapResolution = alphaMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeights(0,0, heightMap);
			
			terrainData.SetAlphamaps(0, 0, splatData);
			
			this.terrain = newTile;
			
			if(hasWater)
			{
				water = GameObject.Instantiate(waterPrefab);
				water.transform.position = new Vector3(terrain.transform.position.x + tileSize/2, ceilingHeight*sea_level, terrain.transform.position.z + tileSize/2);
				water.transform.localScale = new Vector3(tileSize/10.0f,tileSize/10.0f,tileSize/10.0f);
			}
		}
		
		private void generateTerrainTexture(TerrainData data)
		{
			SplatPrototype[] texture = new SplatPrototype[4];
			Texture2D sand = (Texture2D)Resources.Load("SandAlbedo"); 
			texture[0] = new SplatPrototype();
			texture[0].texture = sand;
			
			Texture2D grass = (Texture2D)Resources.Load("GrassHillAlbedo"); 
			texture[1] = new SplatPrototype();
			texture[1].texture = grass;
			
			Texture2D rockygrass = (Texture2D)Resources.Load("GrassRockyAlbedo"); 
			texture[2] = new SplatPrototype();
			texture[2].texture = rockygrass;
			
			Texture2D rockycliff = (Texture2D)Resources.Load("CliffAlbedoSpecular"); 
			texture[3] = new SplatPrototype();
			texture[3].texture = rockycliff;
			
			data.splatPrototypes = texture;
		}
		
		public void generateComplexHeightMap()
		{
			int nRows = heightMapResolution;
			int nCols = heightMapResolution;
			float[,] heights = new float[nRows, nCols];
			
			for (int y = 0; y < nCols; y++)
			{
				for (int x = 0; x < nRows; x++)
				{
					heights[x,y] = (float)((module.GetValue(((double)x + (((double)nRows - 1) * ((double)position.y))) / (double)noiseScale,((double)y + (((double)nCols - 1) * ((double)position.x))) / (double)noiseScale, 1)));
					
					if(heights[x,y] < minAltitude)
					{
						minAltitude = heights[x,y];
					}
					
					if(heights[x,y] < minAlt)
					{
						minAlt = heights[x,y];
						//Debug.Log("Min Altitude = " + minAlt + " Max Altitude = " + maxAlt);
					}
					
					if(heights[x,y] > maxAlt)
					{
						maxAlt = heights[x,y];
						//Debug.Log("Min Altitude = " + minAlt + " Max Altitude = " + maxAlt);
						
					}
				}
			}
			
			heightMap = heights;
		}
		
		public void generateDetailMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[alphaMapResolution, alphaMapResolution, alphaLayers];
			
			for (int y = 0; y < alphaMapResolution; y++)
			{
				for (int x = 0; x < alphaMapResolution; x++)
				{
					// Normalise x/y coordinates to range 0-1 
					float y_01 = (float)y/(float)alphaMapResolution;
					float x_01 = (float)x/(float)alphaMapResolution;
					
					int equivX = Mathf.RoundToInt(x_01 * heightMapResolution);
					int equivY = Mathf.RoundToInt(y_01 * heightMapResolution);
					
					// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
					float height = getHeight(equivX,equivY);
					
					// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
					//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
					
					// Calculate the steepness of the terrain
					float steepness = getSteepness(equivX, equivY);
					
					// Setup an array to record the mix of texture weights at this point
					float[] splatWeights = new float[alphaLayers];
					
					// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
					
					float cliffThreshhold = 0.009f;
					
					//Sand
					splatWeights[0] = ((1f - height) - (1 - sea_level)) - steepness*3f;
					
					if(splatWeights[0] < 0)
					{
						splatWeights[0] = 0;
					}
					
					if(height < 0.2 && steepness < cliffThreshhold)
					{
						//splatWeights[0] = 1f;
					}
					
					//Grass
					splatWeights[1] = (height - sea_level) - steepness*3f;
					
					if(splatWeights[1] < 0)
					{
						splatWeights[1] = 0;
					}
					
					if(height > 0.2 && height < 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[1] = 1f;
					}
					
					//RockyGrass
					splatWeights[2] = (height - 0.5f) - steepness*3f;
					
					if(splatWeights[2] < 0)
					{
						splatWeights[2] = 0;
					}
					
					if(height > 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[2] = 1f;
					}
					
					//Cliff
					splatWeights[3] = 0f;
					
					if(steepness >= cliffThreshhold)
					{
						splatWeights[3] = steepness*10f;
					}
					
					float weightSum = splatWeights.Sum();
					
					// Loop through each terrain texture
					for(int i = 0; i<alphaLayers; i++)
					{
						// Assign this point to the splatmap array
						splatmapData[x, y, i] = splatWeights[i]/weightSum;
					}
				}
			}
			
			splatData = splatmapData;
		}
		
		public void generateSplatMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[alphaMapResolution, alphaMapResolution, alphaLayers];
			
			for (int y = 0; y < alphaMapResolution; y++)
			{
				for (int x = 0; x < alphaMapResolution; x++)
				{
					// Normalise x/y coordinates to range 0-1 
					float y_01 = (float)y/(float)alphaMapResolution;
					float x_01 = (float)x/(float)alphaMapResolution;
					
					int equivX = Mathf.RoundToInt(x_01 * heightMapResolution);
					int equivY = Mathf.RoundToInt(y_01 * heightMapResolution);
					
					// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
					float height = getHeight(equivX,equivY);
					
					// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
					//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
					
					// Calculate the steepness of the terrain
					float steepness = getSteepness(equivX, equivY);
					
					// Setup an array to record the mix of texture weights at this point
					float[] splatWeights = new float[alphaLayers];
					
					// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
					
					float cliffThreshhold = 0.009f;
					
					//Sand
					splatWeights[0] = ((1f - height) - (1-sea_level*3)) - steepness*3f;
					
					if(splatWeights[0] < 0)
					{
						splatWeights[0] = 0;
					}
					
					if(height < 0.2 && steepness < cliffThreshhold)
					{
						//splatWeights[0] = 1f;
					}
					
					//Grass
					splatWeights[1] = (height - sea_level/2) - steepness*3f;
					
					if(splatWeights[1] < 0)
					{
						splatWeights[1] = 0;
					}
					
					if(height > 0.2 && height < 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[1] = 1f;
					}
					
					//RockyGrass
					splatWeights[2] = (height - 0.5f) - steepness*3f;
					
					if(splatWeights[2] < 0)
					{
						splatWeights[2] = 0;
					}
					
					if(height > 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[2] = 1f;
					}
					
					//Cliff
					splatWeights[3] = 0f;
					
					if(steepness >= cliffThreshhold)
					{
						splatWeights[3] = steepness*10f;
					}
					
					float weightSum = splatWeights.Sum();
					
					// Loop through each terrain texture
					for(int i = 0; i<alphaLayers; i++)
					{
						// Assign this point to the splatmap array
						splatmapData[x, y, i] = splatWeights[i]/weightSum;
					}
				}
			}
			
			splatData = splatmapData;
		}
		
		public static string getTerrainName(int x, int y){
			string terrainName = "Terrain:" + x + "," + y;
			return terrainName;
		}
		
		public static Vector2 getGridCoordinate(Vector3 position){
			Vector2 coordinate = new Vector2 ();
			
			coordinate.x = Mathf.FloorToInt (position.x / (size));
			coordinate.y = Mathf.FloorToInt (position.z / (size));
			
			return coordinate;
		}
		
		public static int getGridDistance(Vector2 pos1, Vector2 pos2){
			return Mathf.FloorToInt(Mathf.Sqrt ( Mathf.Pow((pos1.x - pos2.x),2) + Mathf.Pow((pos1.y - pos2.y),2)));
		}
		
		public struct LocalCoordinate
		{
			public Vector2 tileAddress;
			public Vector2 localCoordinate;
		}
		
		/// <summary>
		/// Converts worldspace coordinates to local coordinates in a tile
		/// Since different aspects of a tile may have different widths,
		/// width must be specified
		/// </summary>
		/// <returns>The to local.</returns>
		/// <param name="position">Position.</param>
		/// <param name="width">Width.</param>
		public static LocalCoordinate WorldToLocal(Vector3 position, int width)
		{
			LocalCoordinate result = new LocalCoordinate();
			
			result.tileAddress = getGridCoordinate(position);
			
			float remainderX = position.x - (result.tileAddress.x * size);
			float remainderY = position.y - (result.tileAddress.y * size);
			
			float relativeX = Mathf.FloorToInt(remainderX * width);
			float relativeY = Mathf.FloorToInt(remainderX * width);
			
			result.localCoordinate.x = relativeX;
			result.localCoordinate.y = relativeY;
			
			return result;
		}
	}
}

