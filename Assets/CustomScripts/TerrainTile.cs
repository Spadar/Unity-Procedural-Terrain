//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Diagnostics;
using UnityEngine;

namespace AssemblyCSharp
{
	public class TerrainTile
	{
		public static LibNoise.ModuleBase module;
		public string tileName;
		public Vector2 position;
		public int dist;
		
		public GameObject terrain;
		public float[,] heightMap;
		public float[,,] splatData;
		
		public GameObject water;
		
		public static bool enableCaching = false;
		
		public int heightMapResolution;
		public int splatMapResolution;
		
		private static double minAlt = 1.0;
		private static double maxAlt = 0.0;
		
		private readonly int alphaLayers = 4;
				
		private float minAltitude = 1.0f;
		
		public bool isLoading = false;
		
		public TerrainTile[] neighbors = new TerrainTile[4];
		
		public bool hasWater
		{
			get
			{
				if(minAltitude < WorldTerrain.sea_level)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool IsGenerated
		{
			get
			{
				if(heightMap != null && splatData != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool isLoaded
		{
			get
			{
				if(terrain != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public Terrain getTerrain
		{
			get
			{
				if(terrain != null)
				{
					return (Terrain)terrain.GetComponent(typeof(Terrain));
				}
				else
				{
					return null;
				}
			}
		}
		
		public TerrainTile(Vector2 position, string tileName, int dist, float[,] heightMap, float[,,] splatData, GameObject terrain)
		{
			this.position = position;
			this.terrain = terrain;
			this.dist = dist;
			this.heightMap = heightMap;
			this.tileName = tileName;
			this.splatData = splatData;
			
			if(true)
			{
				this.heightMapResolution = (WorldTerrain.heightMapResolution - 1) + 1;
				this.splatMapResolution = WorldTerrain.alphaMapResolution;
			}
			else
			{
				this.heightMapResolution = (WorldTerrain.heightMapResolution - 1)/2 + 1;
				this.splatMapResolution = WorldTerrain.alphaMapResolution/2;
			}
		}
		
		public void setHeight(int x, int y, float value)
		{
			if(heightMap != null && (x < heightMapResolution && x >= 0) && (y < heightMapResolution && y >= 0))
			{
				heightMap[x,y] = value;
				
				Terrain terr = (Terrain)terrain.GetComponent(typeof(Terrain));
				terr.terrainData.SetHeights(0,0,heightMap);
			}
		}
		
		public float getHeight(int x, int y)
		{
			if(heightMap != null)
			{
				return heightMap[x,y];
			}
			else
			{
				return 0f;
			}
		}
		
		public float getSteepness(int x, int y)
		{
			float maxSteepness = 0;
			
			float centralHeight = getHeight(x,y);
			
			//Loop through all the neighboring heights
			for(int xI = -1; xI <= 1; xI++)
			{
				for(int yI = -1; yI <= 1; yI++)
				{
					int sampleX = x + xI;
					int sampleY = y + yI;
					//Don't attempt to sample if we're outside the bounds of the array.
					if(sampleX >= 0 && sampleX <= Mathf.Sqrt(heightMap.Length) - 1)
					{
						if(sampleY >= 0 && sampleY <= Mathf.Sqrt(heightMap.Length) - 1)
						{
							float steepness = Mathf.Abs(centralHeight - getHeight(sampleX, sampleY));
							if(maxSteepness < steepness)
							{
								maxSteepness = steepness;
							}
						}
					}
				}
			}
			
			//We want the same result regardless of the heightmap resolution or the size of the terrain tiles.
			float normalizationFactor = WorldTerrain.size / (heightMapResolution - 1f);
			
			return maxSteepness / normalizationFactor;
		}
		
		public void unload()
		{
			GameObject.DestroyImmediate(terrain);
			if(water != null)
			{
				GameObject.DestroyImmediate(water);
			}
		}
		
		public void load()
		{
			GameObject newTile = new GameObject();
			
			newTile.name = tileName;
			
			//newTile.transform.position = new Vector3 (((int)position.x - 250) * (WorldTerrain.size), 0, ((int)position.y - 250) * (WorldTerrain.size));
			newTile.transform.position = new Vector3 (((int)position.x) * (WorldTerrain.size), 0, ((int)position.y) * (WorldTerrain.size));
			
			
			newTile.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)newTile.GetComponent(typeof(Terrain));
			
			newTile.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)newTile.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
						
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = heightMapResolution;
			terrainData.size = WorldTerrain.dataSize;
			
			terrainData.alphamapResolution = splatMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeights(0,0, heightMap);
			
			terrainData.SetAlphamaps(0, 0, splatData);
			
			this.terrain = newTile;
			
			if(hasWater)
			{
				water = GameObject.Instantiate(WorldTerrain.waterPrefab);
				water.transform.position = new Vector3(terrain.transform.position.x + WorldTerrain.tileSize/2, WorldTerrain.ceilingHeight*WorldTerrain.sea_level, terrain.transform.position.z + WorldTerrain.tileSize/2);
				water.transform.localScale = new Vector3(WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f);
			}
			
			setNeighbors();
			
			UnityEngine.Debug.Log(heightMapResolution);
		}
		
		private void generateTerrainTexture(TerrainData data)
		{
			SplatPrototype[] texture = new SplatPrototype[4];
			Texture2D sand = (Texture2D)Resources.Load("SandAlbedo"); 
			texture[0] = new SplatPrototype();
			texture[0].texture = sand;
			
			Texture2D grass = (Texture2D)Resources.Load("GrassHillAlbedo"); 
			texture[1] = new SplatPrototype();
			texture[1].texture = grass;
			
			Texture2D rockygrass = (Texture2D)Resources.Load("GrassRockyAlbedo"); 
			texture[2] = new SplatPrototype();
			texture[2].texture = rockygrass;
			
			Texture2D rockycliff = (Texture2D)Resources.Load("CliffAlbedoSpecular"); 
			texture[3] = new SplatPrototype();
			texture[3].texture = rockycliff;
			
			data.splatPrototypes = texture;
		}
		
		public void generateComplexHeightMap()
		{
			Stopwatch timer = new Stopwatch();
			timer.Start();
			
			float[,] loadedHeights = tryLoadHeightMap();
		
			int nRows = heightMapResolution;
			int nCols = heightMapResolution;
			float[,] heights = new float[nRows, nCols];
			
			int heightRatio = (WorldTerrain.heightMapResolution - 1)/(heightMapResolution - 1);
			
			if(loadedHeights == null || loadedHeights.GetLength(0) != nRows || loadedHeights.GetLength(1) != nCols)
			{
				for (int y = 0; y < nCols; y++)
				{
					for (int x = 0; x < nRows; x++)
					{
						double xCoord = ((double)(x * heightRatio) + (((double)WorldTerrain.heightMapResolution - 1) * ((double)position.y))) / (double)WorldTerrain.noiseScale;
						double yCoord = ((double)(y * heightRatio) + (((double)WorldTerrain.heightMapResolution - 1) * ((double)position.x))) / (double)WorldTerrain.noiseScale;
						heights[x,y] = (float)((module.GetValue(xCoord,yCoord, 1)));
					}
				}
				
				trySaveHeightMap(heights);
			}
			else
			{
				heights = loadedHeights;
			}
			
				heightMap = heights;
				timer.Stop();
				getMinAltitude();
		}
		
		private void getMinAltitude()
		{
			foreach(float height in heightMap)
			{
				if(minAltitude > height)
				{
					minAltitude = height;
				}	
			}
		}
		
		private float[,,] tryLoadSplatMap()
		{
			float[,,] data = null;
			
			string filename = WorldTerrain.resourcesPath + @"\splatMapCache\" + tileName + "splatmap.dat";
			if(File.Exists(filename))
			{
				using (FileStream stream = File.Open(filename,FileMode.Open)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					
					// Deserialize the hashtable from the file and  
					// assign the reference to the local variable.
					data = (float[,,]) formatter.Deserialize(stream);
				}
			}
			
			return data;
		}
		
		private void trySaveSplatMap(float[,,] heights)
		{
			if(enableCaching)
			{
				string filename = WorldTerrain.resourcesPath + @"\splatMapCache\" + tileName + "splatmap.dat";
				if(File.Exists(filename))
				{
					File.Delete(filename);
				}
				using (FileStream stream = File.Create(filename)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					formatter.Serialize(stream, heights);
					stream.Close();
				}
			}
		}
		
		private float[,] tryLoadHeightMap()
		{
			float[,] heights = null;
		
			string filename = WorldTerrain.resourcesPath + @"\heightMapCache\" + tileName + "heightmap.dat";
			if(File.Exists(filename))
			{
				using (FileStream stream = File.Open(filename,FileMode.Open)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					
					heights = (float[,]) formatter.Deserialize(stream);
				}
			}
			
			return heights;
		}
		
		private void trySaveHeightMap(float[,] heights)
		{
			if(enableCaching)
			{
				string filename = WorldTerrain.resourcesPath + @"\heightMapCache\" + tileName + "heightmap.dat";
				if(File.Exists(filename))
				{
					File.Delete(filename);
				}
				using (FileStream stream = File.Create(filename)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					formatter.Serialize(stream, heights);
					stream.Close();
				}
			}
		}
		
		public void generateSplatMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[splatMapResolution, splatMapResolution, alphaLayers];
			
			float[,,] loadedSplatmapData = tryLoadSplatMap();
			
			if(loadedSplatmapData == null || loadedSplatmapData.GetLength(0) != splatMapResolution || loadedSplatmapData.GetLength(1) != splatMapResolution || loadedSplatmapData.GetLength(2) != alphaLayers)
			{
				for (int y = 0; y < splatMapResolution; y++)
				{
					for (int x = 0; x < splatMapResolution; x++)
					{
						// Normalise x/y coordinates to range 0-1 
						float y_01 = (float)y/(float)splatMapResolution;
						float x_01 = (float)x/(float)splatMapResolution;
						
						int equivX = Mathf.RoundToInt(x_01 * heightMapResolution);
						int equivY = Mathf.RoundToInt(y_01 * heightMapResolution);
						
						// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
						float height = getHeight(equivX,equivY);
						
						// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
						//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
						
						// Calculate the steepness of the terrain
						float steepness = getSteepness(equivX, equivY);
						
						// Setup an array to record the mix of texture weights at this point
						float[] splatWeights = new float[alphaLayers];
						
						// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
						
						float cliffThreshhold = 0.009f;
						
						SplatMapComparator[] heightComparators = WorldTerrain.heightTextureComparators.Values.ToArray();
						//Height weights
						for(int i = 0; i < heightComparators.Length; i++)
						{
							SplatMapComparator comparator = heightComparators[i];
							
							float weight = comparator.calculateValue(height);
							splatWeights[i] = weight;
						}
						
						SplatMapComparator[] steepnessComparators = WorldTerrain.steepnessTextureComparators.Values.ToArray();
						//Height weights
						for(int i = 0; i < steepnessComparators.Length; i++)
						{
							SplatMapComparator comparator = steepnessComparators[i];
							
							float weight = comparator.calculateValue(steepness);
							if(WorldTerrain.steepnessTextureComparators["cliff"] != comparator)
							{
								splatWeights[i] = splatWeights[i] - weight;
							}
							else
							{
								if(splatWeights[i] < weight)
								{
									splatWeights[i] = weight;
								}
							}
						}
						
						/*
						//Sand
						splatWeights[0] = ((1f - height) - (1 - WorldTerrain.sea_level)) - steepness*3f;
						
						if(splatWeights[0] < 0)
						{
							splatWeights[0] = 0;
						}
						
						if(height < 0.2 && steepness < cliffThreshhold)
						{
							//splatWeights[0] = 1f;
						}
						
						//Grass
						splatWeights[1] = (height - WorldTerrain.sea_level) - steepness*3f;
						
						if(splatWeights[1] < 0)
						{
							splatWeights[1] = 0;
						}
						
						if(height > 0.2 && height < 0.4 && steepness < cliffThreshhold)
						{
							//splatWeights[1] = 1f;
						}
						
						//RockyGrass
						splatWeights[2] = (height - 0.5f) - steepness*3f;
						
						if(splatWeights[2] < 0)
						{
							splatWeights[2] = 0;
						}
						
						if(height > 0.4 && steepness < cliffThreshhold)
						{
							//splatWeights[2] = 1f;
						}
						
						//Cliff
						splatWeights[3] = 0f;
						
						if(steepness >= cliffThreshhold)
						{
							splatWeights[3] = steepness*10f;
						}
						*/
						
						float weightSum = splatWeights.Sum();
						
						// Loop through each terrain texture
						for(int i = 0; i<alphaLayers; i++)
						{
							// Assign this point to the splatmap array
							splatmapData[x, y, i] = splatWeights[i]/weightSum;
						}
					}
				}
				
				trySaveSplatMap(splatmapData);
			}
			else
			{
				splatmapData = loadedSplatmapData;
			}
			
			splatData = splatmapData;
		}
		
		public void setNeighbors()
		{
			List<string> neighbors = new List<string>();
			
			int tileX = (int)position.x;
			int tileY = (int)position.y;
			
			neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1));
			neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1));
			
			List<TerrainTile> terrains = new List<TerrainTile>();
			
			foreach(string neighbor in neighbors)
			{
				TerrainTile neighborTile = null;
				if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
				{
					terrains.Add(neighborTile);
				}
				else
				{
					terrains.Add(null);
				}
			}
			
			if(terrains.Count == 4)
			{
				Terrain tileTerrain = (Terrain)terrain.GetComponent(typeof(Terrain));
				
				Terrain left = null;
				Terrain top = null;
				Terrain right = null;
				Terrain bottom = null;
				
				if(terrains[0] != null)
				{
					left = terrains[0].getTerrain;
					
					if(!terrains[0].neighbors.Contains (this))
					{
						terrains[0].setNeighbors();
					}
				}
				if(terrains[1] != null)
				{
					top = terrains[1].getTerrain;
					
					if(!terrains[1].neighbors.Contains (this))
					{
						terrains[1].setNeighbors();
					}
				}
				if(terrains[2] != null)
				{
					right = terrains[2].getTerrain;
					
					if(!terrains[2].neighbors.Contains (this))
					{
						terrains[2].setNeighbors();
					}
				}
				if(terrains[3] != null)
				{
					bottom = terrains[3].getTerrain;
					
					if(!terrains[3].neighbors.Contains (this))
					{
						terrains[3].setNeighbors();
					}
				}
				
				this.neighbors = terrains.ToArray();
				
				tileTerrain.SetNeighbors(left, top, right, bottom);
			}
			
			
		}
		
		public void stitchTerrainBorders()
		{
			//The name of a tile mapped to the edge of the heightmap it lies along.
			Dictionary<string, string> neighbors = new Dictionary<string, string>();
			
			int tileX = (int)position.x;
			int tileY = (int)position.y;
			
			neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY), "left");
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1), "top");
			neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY), "right");
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1), "bottom");
			
			
			foreach(string neighbor in neighbors.Keys)
			{
				TerrainTile neighborTile = null;
				if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
				{
					if(neighborTile.heightMapResolution != heightMapResolution)
					{
						string edge = neighbors[neighborTile.tileName];
						
						if(heightMapResolution > neighborTile.heightMapResolution)
						{
							int factor = (heightMapResolution - 1)/(neighborTile.heightMapResolution - 1);
							
							bool incrementX = false;
							bool incrementY = false;
							
							int startX = 0;
							int startY = 0;
							
							//Determining which edge needs to be traversed.
							switch(edge)
							{
								case "left":
								{
									incrementY = true;
									break;
								}
								case "top":
								{
									incrementX = true;
									startY = heightMapResolution;
									break;
								}
								case "right":
								{
									incrementY = true;
									startX = heightMapResolution;
									break;
								}
								case "bottom":
								{
									incrementX = true;
									break;
								}
							}
							
							for(int i = 0; i < heightMapResolution; i++)
							{
								Vector2 edgePoint = null;
								
								if(incrementX)
								{
									edgePoint = new Vector2(i, startY);
								}
								else if(incrementY)
								{
									edgePoint = new Vector2(startX, i);
								}
							}
							
							
							
							
						}
					}
				}
			}
		}
	}
}

