//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using UnityEngine;

namespace AssemblyCSharp
{
	public class TerrainTile
	{
		public static LibNoise.ModuleBase module;
		public string tileName;
		public Vector2 position;
		public int dist;
		
		public GameObject terrain;
		public float[,] heightMap;
		public float[,,] splatData;
		
		public GameObject water;
				
		private static double minAlt = 1.0;
		private static double maxAlt = 0.0;
		
		private readonly int alphaLayers = 4;
				
		private float minAltitude = 1.0f;
		
		public bool isLoading = false;
		
		public TerrainTile[] neighbors = new TerrainTile[4];
		
		public bool hasWater
		{
			get
			{
				if(minAltitude < WorldTerrain.sea_level)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool IsGenerated
		{
			get
			{
				if(heightMap != null && splatData != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool isLoaded
		{
			get
			{
				if(terrain != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public Terrain getTerrain
		{
			get
			{
				if(terrain != null)
				{
					return (Terrain)terrain.GetComponent(typeof(Terrain));
				}
				else
				{
					return null;
				}
			}
		}
		
		public TerrainTile(Vector2 position, string tileName, int dist, float[,] heightMap, float[,,] splatData, GameObject terrain)
		{
			this.position = position;
			this.terrain = terrain;
			this.dist = dist;
			this.heightMap = heightMap;
			this.tileName = tileName;
			this.splatData = splatData;
		}
		
		public void setHeight(int x, int y, float value)
		{
			if(heightMap != null && (x < WorldTerrain.heightMapResolution && x >= 0) && (y < WorldTerrain.heightMapResolution && y >= 0))
			{
				heightMap[x,y] = value;
				
				Terrain terr = (Terrain)terrain.GetComponent(typeof(Terrain));
				terr.terrainData.SetHeights(0,0,heightMap);
			}
		}
		
		public float getHeight(int x, int y)
		{
			if(heightMap != null)
			{
				return heightMap[x,y];
			}
			else
			{
				return 0f;
			}
		}
		
		public float getSteepness(int x, int y)
		{
			float maxSteepness = 0;
			
			float centralHeight = getHeight(x,y);
			
			//Loop through all the neighboring heights
			for(int xI = -1; xI <= 1; xI++)
			{
				for(int yI = -1; yI <= 1; yI++)
				{
					int sampleX = x + xI;
					int sampleY = y + yI;
					//Don't attempt to sample if we're outside the bounds of the array.
					if(sampleX >= 0 && sampleX <= Mathf.Sqrt(heightMap.Length) - 1)
					{
						if(sampleY >= 0 && sampleY <= Mathf.Sqrt(heightMap.Length) - 1)
						{
							float steepness = Mathf.Abs(centralHeight - getHeight(sampleX, sampleY));
							if(maxSteepness < steepness)
							{
								maxSteepness = steepness;
							}
						}
					}
				}
			}
			
			//We want the same result regardless of the heightmap resolution or the size of the terrain tiles.
			float normalizationFactor = WorldTerrain.size / (WorldTerrain.heightMapResolution - 1f);
			
			return maxSteepness / normalizationFactor;
		}
		
		public void unload()
		{
			GameObject.DestroyImmediate(terrain);
			if(water != null)
			{
				GameObject.DestroyImmediate(water);
			}
		}
		
		public void load()
		{
			GameObject newTile = new GameObject();
			
			newTile.name = tileName;
			
			//newTile.transform.position = new Vector3 (((int)position.x - 250) * (WorldTerrain.size), 0, ((int)position.y - 250) * (WorldTerrain.size));
			newTile.transform.position = new Vector3 (((int)position.x) * (WorldTerrain.size), 0, ((int)position.y) * (WorldTerrain.size));
			
			
			newTile.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)newTile.GetComponent(typeof(Terrain));
			
			newTile.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)newTile.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
						
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = WorldTerrain.heightMapResolution;
			terrainData.size = WorldTerrain.dataSize;
			
			terrainData.alphamapResolution = WorldTerrain.alphaMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeights(0,0, heightMap);
			
			terrainData.SetAlphamaps(0, 0, splatData);
			
			this.terrain = newTile;
			
			if(hasWater)
			{
				water = GameObject.Instantiate(WorldTerrain.waterPrefab);
				water.transform.position = new Vector3(terrain.transform.position.x + WorldTerrain.tileSize/2, WorldTerrain.ceilingHeight*WorldTerrain.sea_level, terrain.transform.position.z + WorldTerrain.tileSize/2);
				water.transform.localScale = new Vector3(WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f);
			}
			
			setNeighbors();
		}
		
		private void generateTerrainTexture(TerrainData data)
		{
			SplatPrototype[] texture = new SplatPrototype[4];
			Texture2D sand = (Texture2D)Resources.Load("SandAlbedo"); 
			texture[0] = new SplatPrototype();
			texture[0].texture = sand;
			
			Texture2D grass = (Texture2D)Resources.Load("GrassHillAlbedo"); 
			texture[1] = new SplatPrototype();
			texture[1].texture = grass;
			
			Texture2D rockygrass = (Texture2D)Resources.Load("GrassRockyAlbedo"); 
			texture[2] = new SplatPrototype();
			texture[2].texture = rockygrass;
			
			Texture2D rockycliff = (Texture2D)Resources.Load("CliffAlbedoSpecular"); 
			texture[3] = new SplatPrototype();
			texture[3].texture = rockycliff;
			
			data.splatPrototypes = texture;
		}
		
		public void generateComplexHeightMap()
		{
			int nRows = WorldTerrain.heightMapResolution;
			int nCols = WorldTerrain.heightMapResolution;
			float[,] heights = new float[nRows, nCols];
			
			for (int y = 0; y < nCols; y++)
			{
				for (int x = 0; x < nRows; x++)
				{
					heights[x,y] = (float)((module.GetValue(((double)x + (((double)nRows - 1) * ((double)position.y))) / (double)WorldTerrain.noiseScale,((double)y + (((double)nCols - 1) * ((double)position.x))) / (double)WorldTerrain.noiseScale, 1)));
					
					if(heights[x,y] < minAltitude)
					{
						minAltitude = heights[x,y];
					}
					
					if(heights[x,y] < minAlt)
					{
						minAlt = heights[x,y];
						//Debug.Log("Min Altitude = " + minAlt + " Max Altitude = " + maxAlt);
					}
					
					if(heights[x,y] > maxAlt)
					{
						maxAlt = heights[x,y];
						//Debug.Log("Min Altitude = " + minAlt + " Max Altitude = " + maxAlt);
						
					}
				}
			}
			
			heightMap = heights;
		}
		
		public void generateDetailMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[WorldTerrain.alphaMapResolution, WorldTerrain.alphaMapResolution, alphaLayers];
			
			for (int y = 0; y < WorldTerrain.alphaMapResolution; y++)
			{
				for (int x = 0; x < WorldTerrain.alphaMapResolution; x++)
				{
					// Normalise x/y coordinates to range 0-1 
					float y_01 = (float)y/(float)WorldTerrain.alphaMapResolution;
					float x_01 = (float)x/(float)WorldTerrain.alphaMapResolution;
					
					int equivX = Mathf.RoundToInt(x_01 * WorldTerrain.heightMapResolution);
					int equivY = Mathf.RoundToInt(y_01 * WorldTerrain.heightMapResolution);
					
					// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
					float height = getHeight(equivX,equivY);
					
					// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
					//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
					
					// Calculate the steepness of the terrain
					float steepness = getSteepness(equivX, equivY);
					
					// Setup an array to record the mix of texture weights at this point
					float[] splatWeights = new float[alphaLayers];
					
					// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
					
					float cliffThreshhold = 0.009f;
					
					SplatMapComparator[] comparators = WorldTerrain.heightTextureComparators.Values.ToArray();
					//Height weights
					for(int i = 0; i >= comparators.Length; i++)
					{
						SplatMapComparator comparator = comparators[i];
						
						float weight = comparator.calculateValue(height);
						splatWeights[i] = weight;
					}
					
					/*
					//Sand
					splatWeights[0] = ((1f - height) - (1 - WorldTerrain.sea_level)) - steepness*3f;
					
					if(splatWeights[0] < 0)
					{
						splatWeights[0] = 0;
					}
					
					if(height < 0.2 && steepness < cliffThreshhold)
					{
						//splatWeights[0] = 1f;
					}
					
					//Grass
					splatWeights[1] = (height - WorldTerrain.sea_level) - steepness*3f;
					
					if(splatWeights[1] < 0)
					{
						splatWeights[1] = 0;
					}
					
					if(height > 0.2 && height < 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[1] = 1f;
					}
					
					//RockyGrass
					splatWeights[2] = (height - 0.5f) - steepness*3f;
					
					if(splatWeights[2] < 0)
					{
						splatWeights[2] = 0;
					}
					
					if(height > 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[2] = 1f;
					}
					
					//Cliff
					splatWeights[3] = 0f;
					
					if(steepness >= cliffThreshhold)
					{
						splatWeights[3] = steepness*10f;
					}
					*/
					
					float weightSum = splatWeights.Sum();
					
					
					// Loop through each terrain texture
					for(int i = 0; i<alphaLayers; i++)
					{
						// Assign this point to the splatmap array
						splatmapData[x, y, i] = splatWeights[i]/weightSum;
					}
				}
			}
			
			splatData = splatmapData;
		}
		
		public void generateSplatMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[WorldTerrain.alphaMapResolution, WorldTerrain.alphaMapResolution, alphaLayers];
			
			
			
			for (int y = 0; y < WorldTerrain.alphaMapResolution; y++)
			{
				for (int x = 0; x < WorldTerrain.alphaMapResolution; x++)
				{
					// Normalise x/y coordinates to range 0-1 
					float y_01 = (float)y/(float)WorldTerrain.alphaMapResolution;
					float x_01 = (float)x/(float)WorldTerrain.alphaMapResolution;
					
					int equivX = Mathf.RoundToInt(x_01 * WorldTerrain.heightMapResolution);
					int equivY = Mathf.RoundToInt(y_01 * WorldTerrain.heightMapResolution);
					
					// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
					float height = getHeight(equivX,equivY);
					
					// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
					//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
					
					// Calculate the steepness of the terrain
					float steepness = getSteepness(equivX, equivY);
					
					// Setup an array to record the mix of texture weights at this point
					float[] splatWeights = new float[alphaLayers];
					
					// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
					
					float cliffThreshhold = 0.009f;
					
					SplatMapComparator[] heightComparators = WorldTerrain.heightTextureComparators.Values.ToArray();
					//Height weights
					for(int i = 0; i < heightComparators.Length; i++)
					{
						SplatMapComparator comparator = heightComparators[i];
						
						float weight = comparator.calculateValue(height);
						splatWeights[i] = weight;
					}
					
					SplatMapComparator[] steepnessComparators = WorldTerrain.steepnessTextureComparators.Values.ToArray();
					//Height weights
					for(int i = 0; i < steepnessComparators.Length; i++)
					{
						SplatMapComparator comparator = steepnessComparators[i];
						
						float weight = comparator.calculateValue(steepness);
						if(WorldTerrain.steepnessTextureComparators["cliff"] != comparator)
						{
							splatWeights[i] = splatWeights[i] - weight;
						}
						else
						{
							if(splatWeights[i] < weight)
							{
								splatWeights[i] = weight;
							}
						}
					}
					
					
					
					/*
					//Sand
					splatWeights[0] = ((1f - height) - (1 - WorldTerrain.sea_level)) - steepness*3f;
					
					if(splatWeights[0] < 0)
					{
						splatWeights[0] = 0;
					}
					
					if(height < 0.2 && steepness < cliffThreshhold)
					{
						//splatWeights[0] = 1f;
					}
					
					//Grass
					splatWeights[1] = (height - WorldTerrain.sea_level) - steepness*3f;
					
					if(splatWeights[1] < 0)
					{
						splatWeights[1] = 0;
					}
					
					if(height > 0.2 && height < 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[1] = 1f;
					}
					
					//RockyGrass
					splatWeights[2] = (height - 0.5f) - steepness*3f;
					
					if(splatWeights[2] < 0)
					{
						splatWeights[2] = 0;
					}
					
					if(height > 0.4 && steepness < cliffThreshhold)
					{
						//splatWeights[2] = 1f;
					}
					
					//Cliff
					splatWeights[3] = 0f;
					
					if(steepness >= cliffThreshhold)
					{
						splatWeights[3] = steepness*10f;
					}
					*/
					
					float weightSum = splatWeights.Sum();
					
					
					// Loop through each terrain texture
					for(int i = 0; i<alphaLayers; i++)
					{
						// Assign this point to the splatmap array
						splatmapData[x, y, i] = splatWeights[i]/weightSum;
					}
				}
			}
			
			splatData = splatmapData;
		}
		
		public void setNeighbors()
		{
			List<string> neighbors = new List<string>();
			
			int tileX = (int)position.x;
			int tileY = (int)position.y;
			
			neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1));
			neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1));
			
			List<TerrainTile> terrains = new List<TerrainTile>();
			
			foreach(string neighbor in neighbors)
			{
				TerrainTile neighborTile = null;
				if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
				{
					terrains.Add(neighborTile);
				}
				else
				{
					terrains.Add(null);
				}
			}
			
			if(terrains.Count == 4)
			{
				Terrain tileTerrain = (Terrain)terrain.GetComponent(typeof(Terrain));
				
				Terrain left = null;
				Terrain top = null;
				Terrain right = null;
				Terrain bottom = null;
				
				if(terrains[0] != null)
				{
					left = terrains[0].getTerrain;
					
					if(!terrains[0].neighbors.Contains (this))
					{
						terrains[0].setNeighbors();
					}
				}
				if(terrains[1] != null)
				{
					top = terrains[1].getTerrain;
					
					if(!terrains[1].neighbors.Contains (this))
					{
						terrains[1].setNeighbors();
					}
				}
				if(terrains[2] != null)
				{
					right = terrains[2].getTerrain;
					
					if(!terrains[2].neighbors.Contains (this))
					{
						terrains[2].setNeighbors();
					}
				}
				if(terrains[3] != null)
				{
					bottom = terrains[3].getTerrain;
					
					if(!terrains[3].neighbors.Contains (this))
					{
						terrains[3].setNeighbors();
					}
				}
				
				this.neighbors = terrains.ToArray();
				
				tileTerrain.SetNeighbors(left, top, right, bottom);
			}
			
			
		}
		

	}
}

