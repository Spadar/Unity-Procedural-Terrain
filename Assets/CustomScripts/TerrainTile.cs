//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Diagnostics;
using UnityEngine;

namespace AssemblyCSharp
{
	public class TerrainTile
	{
		public static LibNoise.ModuleBase module;
		public string tileName;
		public Vector2 position;
		public int dist;
		
		public GameObject terrain;
		public float[,] heightMap;
		public float[,,] splatData;
		
		public GameObject water;
		
		public static bool enableCaching = false;
		
		public int heightMapResolution;
		public int splatMapResolution;
		
		private readonly int alphaLayers = 4;
				
		private float minAltitude = 1.0f;
		
		public bool isLoading = false;
		
		public TerrainTile[] neighbors = new TerrainTile[4];
		public List<TerrainTile> stitchedTo = new List<TerrainTile>();
		
		public bool hasWater
		{
			get
			{
				if(minAltitude < WorldTerrain.sea_level)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool IsGenerated
		{
			get
			{
				if(heightMap != null && splatData != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool isLoaded
		{
			get
			{
				if(terrain != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public Terrain getTerrain
		{
			get
			{
				if(terrain != null)
				{
					return (Terrain)terrain.GetComponent(typeof(Terrain));
				}
				else
				{
					return null;
				}
			}
		}
		
		/// <summary>
		/// Gets the edge between this terrain and the given terrain
		/// </summary>
		/// <returns>The edge.</returns>
		/// <param name="neighbors">Neighbors.</param>
		public float[] getEdge(TerrainTile neighbor)
		{
			float[] edge = new float[heightMapResolution];
		
			Vector2 dir = position - neighbor.position;
			
			string vecString = (int)dir.x + "," + (int)dir.y;
			
			bool incrementX = false;
			bool incrementY = false;
			
			int startX = 0;
			int startY = 0;
			
			//Determining which edge needs to be traversed.
			switch(vecString)
			{
				//Left
			case "0,1":
			{
				incrementY = true;
				break;
			}
				//Top
			case "1,0":
			{
				incrementX = true;
				break;
			}
				//Right
			case "0,-1":
			{
				incrementY = true;
				startX = heightMapResolution - 1;
				break;
			}
				//Bottom
			case "-1,0":
			{
				incrementX = true;
				startY = heightMapResolution - 1;
				break;
			}
				//Tiles are not adjacent and no edge is shared
			default:
				{
					return null;
				}
			}
			
			//Construct our array which represents the edge
			for(int i = 0; i < heightMapResolution; i++)
			{
				//Based on the rules we defined earlier we'll move along an edge
				Vector2 edgePoint = new Vector2();
				
				if(incrementX)
				{
					edgePoint = new Vector2(i, startY);
				}
				else if(incrementY)
				{
					edgePoint = new Vector2(startX, i);
				}
				
				//In order to stitch the edges, we'll have to make the edge match the lower resolution terrain's edges.
				//We'll do this by taking the factor we found earlier, which represents the number of ratio of points between the two terrains
				//where the mod of i divided by this factor is 0, the heights on the terrain should line up.
				//If we make a smooth line from mod0 point mod0 point, the high resolution edge should match the low resolution edge. 

				 edge[i] = getHeight((int)edgePoint.x, (int)edgePoint.y);
			}
			
			return edge;
		}
		
		public void setEdge(float[] heights, TerrainTile neighbor)
		{
			Vector2 dir = position - neighbor.position;
			
			string vecString = (int)dir.x + "," + (int)dir.y;
			
			bool incrementX = false;
			bool incrementY = false;
			
			int startX = 0;
			int startY = 0;
			
			//Determining which edge needs to be traversed.
			switch(vecString)
			{
				//Left
			case "0,1":
			{
				incrementY = true;
				break;
			}
				//Top
			case "1,0":
			{
				incrementX = true;
				break;
			}
				//Right
			case "0,-1":
			{
				incrementY = true;
				startX = heightMapResolution - 1;
				break;
			}
				//Bottom
			case "-1,0":
			{
				incrementX = true;
				startY = heightMapResolution - 1;
				break;
			}
			}
			
			//Construct our array which represents the edge
			for(int i = 0; i < heightMapResolution; i++)
			{
				//Based on the rules we defined earlier we'll move along an edge
				Vector2 edgePoint = new Vector2();
				
				if(incrementX)
				{
					edgePoint = new Vector2(i, startY);
				}
				else if(incrementY)
				{
					edgePoint = new Vector2(startX, i);
				}
				
				//In order to stitch the edges, we'll have to make the edge match the lower resolution terrain's edges.
				//We'll do this by taking the factor we found earlier, which represents the number of ratio of points between the two terrains
				//where the mod of i divided by this factor is 0, the heights on the terrain should line up.
				//If we make a smooth line from mod0 point mod0 point, the high resolution edge should match the low resolution edge. 
				
				setHeight((int)edgePoint.x, (int)edgePoint.y, heights[i]);
			}
			
			refreshTerrain();
			neighbor.refreshTerrain();
		}
		
		public TerrainTile(Vector2 position, string tileName, int dist, float[,] heightMap, float[,,] splatData, GameObject terrain)
		{
			this.position = position;
			this.terrain = terrain;
			this.dist = dist;
			this.heightMap = heightMap;
			this.tileName = tileName;
			this.splatData = splatData;
			
			if(dist <= 1)
			{
				this.heightMapResolution = (WorldTerrain.heightMapResolution - 1) + 1;
				this.splatMapResolution = WorldTerrain.alphaMapResolution;
			}
			else
			{
				this.heightMapResolution = (WorldTerrain.heightMapResolution - 1)/2 + 1;
				this.splatMapResolution = WorldTerrain.alphaMapResolution/2;
			}
		}
		
		public void setHeight(int x, int y, float value)
		{
			if(heightMap != null && (x < heightMapResolution && x >= 0) && (y < heightMapResolution && y >= 0))
			{
				heightMap[x,y] = value;
			}
		}
		
		public float getHeight(int x, int y)
		{
			if(heightMap != null)
			{
				return heightMap[x,y];
			}
			else
			{
				return 0f;
			}
		}
		
		public float getSteepness(int x, int y)
		{
			float maxSteepness = 0;
			
			float centralHeight = getHeight(x,y);
			
			//Loop through all the neighboring heights
			for(int xI = -1; xI <= 1; xI++)
			{
				for(int yI = -1; yI <= 1; yI++)
				{
					int sampleX = x + xI;
					int sampleY = y + yI;
					//Don't attempt to sample if we're outside the bounds of the array.
					if(sampleX >= 0 && sampleX <= Mathf.Sqrt(heightMap.Length) - 1)
					{
						if(sampleY >= 0 && sampleY <= Mathf.Sqrt(heightMap.Length) - 1)
						{
							float steepness = Mathf.Abs(centralHeight - getHeight(sampleX, sampleY));
							if(maxSteepness < steepness)
							{
								maxSteepness = steepness;
							}
						}
					}
				}
			}
			
			//We want the same result regardless of the heightmap resolution or the size of the terrain tiles.
			float normalizationFactor = WorldTerrain.size / (heightMapResolution - 1f);
			
			return maxSteepness / normalizationFactor;
		}
		
		public void refreshTerrain()
		{
			Terrain oldTerrain = (Terrain)this.terrain.GetComponent(typeof(Terrain));
			GameObject.DestroyImmediate(oldTerrain);
			
			TerrainCollider oldCollider = (TerrainCollider)this.terrain.GetComponent(typeof(TerrainCollider));
			GameObject.DestroyImmediate(oldCollider);
			
			this.terrain.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)this.terrain.GetComponent(typeof(Terrain));
			
			this.terrain.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)terrain.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
			
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = heightMapResolution;
			terrainData.size = WorldTerrain.dataSize;
			
			terrainData.alphamapResolution = splatMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeights(0,0, heightMap);
			
			terrainData.SetAlphamaps(0, 0, splatData);
		}
		
		public void unload()
		{
			GameObject.DestroyImmediate(terrain);
			if(water != null)
			{
				GameObject.DestroyImmediate(water);
			}
		}
		
		public void load()
		{
			GameObject newTile = new GameObject();
			
			newTile.name = tileName;
			
			//newTile.transform.position = new Vector3 (((int)position.x - 250) * (WorldTerrain.size), 0, ((int)position.y - 250) * (WorldTerrain.size));
			newTile.transform.position = new Vector3 (((int)position.x) * (WorldTerrain.size), 0, ((int)position.y) * (WorldTerrain.size));
			
			
			newTile.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)newTile.GetComponent(typeof(Terrain));
			
			newTile.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)newTile.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
						
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = heightMapResolution;
			terrainData.size = WorldTerrain.dataSize;
			
			terrainData.alphamapResolution = splatMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeights(0,0, heightMap);
			
			terrainData.SetAlphamaps(0, 0, splatData);
			
			this.terrain = newTile;
			
			if(hasWater)
			{
				water = GameObject.Instantiate(WorldTerrain.waterPrefab);
				water.transform.position = new Vector3(terrain.transform.position.x + WorldTerrain.tileSize/2, WorldTerrain.ceilingHeight*WorldTerrain.sea_level, terrain.transform.position.z + WorldTerrain.tileSize/2);
				water.transform.localScale = new Vector3(WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f);
			}
			
			setNeighbors();
		}
		
		private void generateTerrainTexture(TerrainData data)
		{
			SplatPrototype[] texture = new SplatPrototype[4];
			Texture2D sand = (Texture2D)Resources.Load("SandAlbedo"); 
			texture[0] = new SplatPrototype();
			texture[0].texture = sand;
			
			Texture2D grass = (Texture2D)Resources.Load("GrassHillAlbedo"); 
			texture[1] = new SplatPrototype();
			texture[1].texture = grass;
			
			Texture2D rockygrass = (Texture2D)Resources.Load("GrassRockyAlbedo"); 
			texture[2] = new SplatPrototype();
			texture[2].texture = rockygrass;
			
			Texture2D rockycliff = (Texture2D)Resources.Load("CliffAlbedoSpecular"); 
			texture[3] = new SplatPrototype();
			texture[3].texture = rockycliff;
			
			data.splatPrototypes = texture;
		}
		
		public void generateComplexHeightMap()
		{
			Stopwatch timer = new Stopwatch();
			timer.Start();
			
			float[,] loadedHeights = tryLoadHeightMap();
		
			int nRows = heightMapResolution;
			int nCols = heightMapResolution;
			float[,] heights = new float[nRows, nCols];
			
			int heightRatio = (WorldTerrain.heightMapResolution - 1)/(heightMapResolution - 1);
			
			if(loadedHeights == null || loadedHeights.GetLength(0) != nRows || loadedHeights.GetLength(1) != nCols)
			{
				for (int y = 0; y < nCols; y++)
				{
					for (int x = 0; x < nRows; x++)
					{
						double xCoord = ((double)(x * heightRatio) + (((double)WorldTerrain.heightMapResolution - 1) * ((double)position.y))) / (double)WorldTerrain.noiseScale;
						double yCoord = ((double)(y * heightRatio) + (((double)WorldTerrain.heightMapResolution - 1) * ((double)position.x))) / (double)WorldTerrain.noiseScale;
						heights[x,y] = (float)((module.GetValue(xCoord,yCoord, 1)));
					}
				}
				
				trySaveHeightMap(heights);
			}
			else
			{
				heights = loadedHeights;
			}
			
				heightMap = heights;
				timer.Stop();
				getMinAltitude();
		}
		
		private void getMinAltitude()
		{
			foreach(float height in heightMap)
			{
				if(minAltitude > height)
				{
					minAltitude = height;
				}	
			}
		}
		
		private float[,,] tryLoadSplatMap()
		{
			float[,,] data = null;
			
			string filename = WorldTerrain.resourcesPath + @"\splatMapCache\" + tileName + "splatmap.dat";
			if(File.Exists(filename))
			{
				using (FileStream stream = File.Open(filename,FileMode.Open)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					
					// Deserialize the hashtable from the file and  
					// assign the reference to the local variable.
					data = (float[,,]) formatter.Deserialize(stream);
				}
			}
			
			return data;
		}
		
		private void trySaveSplatMap(float[,,] heights)
		{
			if(enableCaching)
			{
				string filename = WorldTerrain.resourcesPath + @"\splatMapCache\" + tileName + "splatmap.dat";
				if(File.Exists(filename))
				{
					File.Delete(filename);
				}
				using (FileStream stream = File.Create(filename)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					formatter.Serialize(stream, heights);
					stream.Close();
				}
			}
		}
		
		private float[,] tryLoadHeightMap()
		{
			float[,] heights = null;
		
			string filename = WorldTerrain.resourcesPath + @"\heightMapCache\" + tileName + "heightmap.dat";
			if(File.Exists(filename))
			{
				using (FileStream stream = File.Open(filename,FileMode.Open)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					
					heights = (float[,]) formatter.Deserialize(stream);
				}
			}
			
			return heights;
		}
		
		private void trySaveHeightMap(float[,] heights)
		{
			if(enableCaching)
			{
				string filename = WorldTerrain.resourcesPath + @"\heightMapCache\" + tileName + "heightmap.dat";
				if(File.Exists(filename))
				{
					File.Delete(filename);
				}
				using (FileStream stream = File.Create(filename)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					formatter.Serialize(stream, heights);
					stream.Close();
				}
			}
		}
		
		public void generateSplatMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[splatMapResolution, splatMapResolution, alphaLayers];
			
			float[,,] loadedSplatmapData = tryLoadSplatMap();
			
			if(loadedSplatmapData == null || loadedSplatmapData.GetLength(0) != splatMapResolution || loadedSplatmapData.GetLength(1) != splatMapResolution || loadedSplatmapData.GetLength(2) != alphaLayers)
			{
				for (int y = 0; y < splatMapResolution; y++)
				{
					for (int x = 0; x < splatMapResolution; x++)
					{
						// Normalise x/y coordinates to range 0-1 
						float y_01 = (float)y/(float)splatMapResolution;
						float x_01 = (float)x/(float)splatMapResolution;
						
						int equivX = Mathf.RoundToInt(x_01 * heightMapResolution);
						int equivY = Mathf.RoundToInt(y_01 * heightMapResolution);
						
						// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
						float height = getHeight(equivX,equivY);
						
						// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
						//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
						
						// Calculate the steepness of the terrain
						float steepness = getSteepness(equivX, equivY);
						
						// Setup an array to record the mix of texture weights at this point
						float[] splatWeights = new float[alphaLayers];
						
						// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
						
						float cliffThreshhold = 0.009f;
						
						SplatMapComparator[] heightComparators = WorldTerrain.heightTextureComparators.Values.ToArray();
						//Height weights
						for(int i = 0; i < heightComparators.Length; i++)
						{
							SplatMapComparator comparator = heightComparators[i];
							
							float weight = comparator.calculateValue(height);
							splatWeights[i] = weight;
						}
						
						SplatMapComparator[] steepnessComparators = WorldTerrain.steepnessTextureComparators.Values.ToArray();
						//Height weights
						for(int i = 0; i < steepnessComparators.Length; i++)
						{
							SplatMapComparator comparator = steepnessComparators[i];
							
							float weight = comparator.calculateValue(steepness);
							if(WorldTerrain.steepnessTextureComparators["cliff"] != comparator)
							{
								splatWeights[i] = splatWeights[i] - weight;
							}
							else
							{
								if(splatWeights[i] < weight)
								{
									splatWeights[i] = weight;
								}
							}
						}
						
						/*
						//Sand
						splatWeights[0] = ((1f - height) - (1 - WorldTerrain.sea_level)) - steepness*3f;
						
						if(splatWeights[0] < 0)
						{
							splatWeights[0] = 0;
						}
						
						if(height < 0.2 && steepness < cliffThreshhold)
						{
							//splatWeights[0] = 1f;
						}
						
						//Grass
						splatWeights[1] = (height - WorldTerrain.sea_level) - steepness*3f;
						
						if(splatWeights[1] < 0)
						{
							splatWeights[1] = 0;
						}
						
						if(height > 0.2 && height < 0.4 && steepness < cliffThreshhold)
						{
							//splatWeights[1] = 1f;
						}
						
						//RockyGrass
						splatWeights[2] = (height - 0.5f) - steepness*3f;
						
						if(splatWeights[2] < 0)
						{
							splatWeights[2] = 0;
						}
						
						if(height > 0.4 && steepness < cliffThreshhold)
						{
							//splatWeights[2] = 1f;
						}
						
						//Cliff
						splatWeights[3] = 0f;
						
						if(steepness >= cliffThreshhold)
						{
							splatWeights[3] = steepness*10f;
						}
						*/
						
						float weightSum = splatWeights.Sum();
						
						// Loop through each terrain texture
						for(int i = 0; i<alphaLayers; i++)
						{
							// Assign this point to the splatmap array
							splatmapData[x, y, i] = splatWeights[i]/weightSum;
						}
					}
				}
				
				trySaveSplatMap(splatmapData);
			}
			else
			{
				splatmapData = loadedSplatmapData;
			}
			
			splatData = splatmapData;
		}
		
		public void stitchNeighbors()
		{
			List<string> neighbors = new List<string>();
			
			int tileX = (int)position.x;
			int tileY = (int)position.y;
			
			neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1));
			neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1));
			
			List<TerrainTile> terrains = new List<TerrainTile>();
			
			foreach(string neighbor in neighbors)
			{
				TerrainTile neighborTile = null;
				if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
				{
					terrains.Add(neighborTile);
				}
				else
				{
					terrains.Add(null);
				}
			}
			
			if(terrains.Count == 4)
			{
				if(terrains[0] != null)
				{
					if(terrains[0].heightMapResolution > heightMapResolution)
					{
						terrains[0].stitchTerrainBorders(this);
					}
				}
				if(terrains[1] != null)
				{
					if(terrains[1].heightMapResolution > heightMapResolution)
					{
						terrains[1].stitchTerrainBorders(this);
					}
				}
				if(terrains[2] != null)
				{
					if(terrains[2].heightMapResolution > heightMapResolution)
					{
						terrains[2].stitchTerrainBorders(this);
					}
				}
				if(terrains[3] != null)
				{
					if(terrains[3].heightMapResolution > heightMapResolution)
					{
						terrains[3].stitchTerrainBorders(this);
					}
				}			
			}
		}
		
		public void setNeighbors()
		{
			List<string> neighbors = new List<string>();
			
			int tileX = (int)position.x;
			int tileY = (int)position.y;
			
			neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1));
			neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1));
			
			List<TerrainTile> terrains = new List<TerrainTile>();
			
			foreach(string neighbor in neighbors)
			{
				TerrainTile neighborTile = null;
				if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
				{
					terrains.Add(neighborTile);
				}
				else
				{
					terrains.Add(null);
				}
			}
			
			if(terrains.Count == 4)
			{
				Terrain tileTerrain = (Terrain)terrain.GetComponent(typeof(Terrain));
				
				Terrain left = null;
				Terrain top = null;
				Terrain right = null;
				Terrain bottom = null;
				
				if(terrains[0] != null)
				{
					left = terrains[0].getTerrain;
					
					if(!terrains[0].neighbors.Contains (this))
					{
						terrains[0].setNeighbors();
					}
				}
				if(terrains[1] != null)
				{
					top = terrains[1].getTerrain;
					
					if(!terrains[1].neighbors.Contains (this))
					{
						terrains[1].setNeighbors();
					}
				}
				if(terrains[2] != null)
				{
					right = terrains[2].getTerrain;
					
					if(!terrains[2].neighbors.Contains (this))
					{
						terrains[2].setNeighbors();
					}
				}
				if(terrains[3] != null)
				{
					bottom = terrains[3].getTerrain;
					
					if(!terrains[3].neighbors.Contains (this))
					{
						terrains[3].setNeighbors();
					}
				}
				
				this.neighbors = terrains.ToArray();
				
				tileTerrain.SetNeighbors(left, top, right, bottom);
			}
		}
		
		public void stitchTerrainBorders(TerrainTile tile)
		{
			//This number will represent how frequently the heights match up for the two edges
			int factor = (heightMapResolution - 1)/(tile.heightMapResolution - 1);	
			
			float[] highResEdge = getEdge(tile);
			float[] lowResEdge = tile.getEdge(this);
			
			float[] stitchedEdge = new float[heightMapResolution];
			
			string commaHighRes = "";
			string commaLowRes = "";
			string commaStitchedEdge = "";
			
			FileInfo lowResFile = new FileInfo(@"C:\Users\Jeffery\Desktop\tileComparisons\" + tile.position.x + "-" + tile.position.y + ".csv");
			FileInfo highResFile = new FileInfo(@"C:\Users\Jeffery\Desktop\tileComparisons\" + position.x + "-" + position.y + ".csv");
			FileInfo stitchComparison = new FileInfo(@"C:\Users\Jeffery\Desktop\tileComparisons\" + position.x + "," + position.y + " edge " + tile.position.x + "," + tile.position.y + ".csv");
			
//			if(!lowResFile.Exists)
//			{
//				using(StreamWriter writer = lowResFile.CreateText())
//				{
//					for(int y = 0; y < tile.heightMapResolution; y++)
//					{
//						for(int x = 0; x < tile.heightMapResolution; x++)
//						{
//							writer.Write(tile.heightMap[x,y]);
//							if(x != tile.heightMapResolution-1)
//							{
//								writer.Write(",,");
//							}
//						}
//						writer.WriteLine();
//					}
//				}
//			}
//			
//			if(!highResFile.Exists)
//			{
//				using(StreamWriter writer = highResFile.CreateText())
//				{
//					for(int y = 0; y < heightMapResolution; y++)
//					{
//						for(int x = 0; x < heightMapResolution; x++)
//						{
//							writer.Write(heightMap[x,y]);
//							if(x != heightMapResolution-1)
//							{
//								writer.Write(",");
//							}
//						}
//						writer.WriteLine();
//					}
//				}
//			}
			
			foreach(float height in lowResEdge)
			{
				commaLowRes += height + ",,";
			}
			
			foreach(float height in highResEdge)
			{
				commaHighRes += height + ",";
			}
			
//			for(int i = 0; i < lowResEdge.Length; i++)
//			{
//				stitchedEdge[i*factor] = lowResEdge[i];
//				
//				if(i > 0 && i < lowResEdge.Length - 1)
//				{
//					float prevHeight = lowResEdge[i-(factor-1)];
//					float nextHeight = lowResEdge[i+(factor-1)];
//					
//					stitchedEdge[(i*factor) - 1] = (prevHeight + nextHeight)/factor;
//				}
//			}

			for(int i = 0; i < heightMapResolution; i++)
			{
				if(i%factor != 0)
				{
					int mod = i%factor;
					
					float prevHeight = highResEdge[i-1];
					float nextHeight = highResEdge[i+1];
					
					float newValue = (prevHeight + nextHeight) / 2f;
					
					stitchedEdge[i] = newValue;
				}
				else
				{
					stitchedEdge[i] = highResEdge[i];
				}
			}
			
			foreach(float height in stitchedEdge)
			{
				commaStitchedEdge += height + ",";
			}
			
			if(!stitchComparison.Exists)
			{
				using(StreamWriter writer = stitchComparison.CreateText())
				{
					writer.WriteLine(commaHighRes);
					writer.WriteLine(commaLowRes);
					writer.WriteLine(commaStitchedEdge);
				}
			}
			setEdge(stitchedEdge, tile);
			if(!stitchedTo.Contains(tile))
			{
				stitchedTo.Add(tile);
			}
			
		}
	}
}

