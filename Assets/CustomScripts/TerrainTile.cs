//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Diagnostics;
using UnityEngine;

namespace AssemblyCSharp
{
	public class TerrainTile
	{
	
		internal struct TerrainEdge
		{
			public readonly bool incrementX;
			public readonly bool incrementY;
			
			public readonly int startX;
			public readonly int startY;
			
			public readonly string edge;
			
			public TerrainEdge(TerrainTile source, TerrainTile neighbor)
			{
				Vector2 dir = source.position - neighbor.position;
				
				string vecString = (int)dir.x + "," + (int)dir.y;
				
				edge = vecString;
				
				incrementX = false;
				incrementY = false;
				
				startX = 0;
				startY = 0;
				
				//Determining which edge needs to be traversed.
				switch(vecString)
				{
						//Left
					case "0,1":
					{
						incrementY = true;
						break;
					}
						//Top
					case "1,0":
					{
						incrementX = true;
						break;
					}
						//Right
					case "0,-1":
					{
						incrementY = true;
						startX = source.heightMapResolution - 1;
						break;
					}
						//Bottom
					case "-1,0":
					{
						incrementX = true;
						startY = source.heightMapResolution - 1;
						break;
					}
					default:
					{
						edge = null;
						break;
					}
				}
			}
		}
	
	
		public static LibNoise.ModuleBase module;
		public string tileName;
		public Vector2 position;		
		public GameObject unityGameObject;
		public float[,] heightMap;
		public float[,,] splatData;
		
		public float[,] highestResolutionHeightMap;
		
		public GameObject water;
		
		public static bool enableCaching = false;
		
		public int heightMapResolution;
		public int splatMapResolution;
		
		private readonly int alphaLayers = 4;
				
		private float minAltitude = 1.0f;
		
		public bool isLoading = false;
		
		public TerrainTile[] neighbors = new TerrainTile[4];
		public List<TerrainTile> stitchedTo = new List<TerrainTile>();
		
		private object stitchLock = new object();
		
		Dictionary<TerrainTile, float[]> savedEdges = new Dictionary<TerrainTile, float[]>();
		
		public DateTime stitchedTime;
		
		List<GameObject> containedObjects = new List<GameObject>();
		
		public bool hasWater
		{
			get
			{
				if(minAltitude < WorldTerrain.sea_level)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool IsGenerated
		{
			get
			{
				if(heightMap != null && splatData != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public bool isLoaded
		{
			get
			{
				if(unityGameObject != null)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		public Terrain UnityTerrain
		{
			get
			{
				if(unityGameObject != null)
				{
					return (Terrain)unityGameObject.GetComponent(typeof(Terrain));
				}
				else
				{
					return null;
				}
			}
		}
		
		public int playerDistance
		{
			get
			{
				return WorldTerrain.getGridDistanceToPlayer(position);
			}
		}
		
		public TerrainTile(Vector2 position, string tileName, float[,] heightMap, float[,,] splatData, GameObject terrain)
		{
			this.position = position;
			this.unityGameObject = terrain;
			this.heightMap = heightMap;
			this.tileName = tileName;
			this.splatData = splatData;
			
			if(playerDistance <= 1)
			{
				this.heightMapResolution = (WorldTerrain.heightMapResolution - 1) + 1;
				this.splatMapResolution = WorldTerrain.alphaMapResolution;
			}
			else
			{
				this.heightMapResolution = (WorldTerrain.heightMapResolution - 1)/2 + 1;
				this.splatMapResolution = WorldTerrain.alphaMapResolution/2;
			}
		}
		
		public void setHeight(int x, int y, float value)
		{
			if(heightMap != null && (x < heightMapResolution && x >= 0) && (y < heightMapResolution && y >= 0))
			{
				heightMap[x,y] = value;
			}
			
			UnityTerrain.terrainData.SetHeights(0,0,heightMap);
			UnityTerrain.drawHeightmap = true;
		}
		
		public float getHeight(int x, int y)
		{
			if(heightMap != null)
			{
				return heightMap[x,y];
			}
			else
			{
				return 0f;
			}
		}
		
		public float getSteepness(int x, int y)
		{
			float maxSteepness = 0;
			
			float centralHeight = getHeight(x,y);
			
			//Loop through all the neighboring heights
			for(int xI = -1; xI <= 1; xI++)
			{
				for(int yI = -1; yI <= 1; yI++)
				{
					int sampleX = x + xI;
					int sampleY = y + yI;
					//Don't attempt to sample if we're outside the bounds of the array.
					if(sampleX >= 0 && sampleX <= Mathf.Sqrt(heightMap.Length) - 1)
					{
						if(sampleY >= 0 && sampleY <= Mathf.Sqrt(heightMap.Length) - 1)
						{
							float steepness = Mathf.Abs(centralHeight - getHeight(sampleX, sampleY));
							if(maxSteepness < steepness)
							{
								maxSteepness = steepness;
							}
						}
					}
				}
			}
			
			//We want the same result regardless of the heightmap resolution or the size of the terrain tiles.
			float normalizationFactor = WorldTerrain.size / (heightMapResolution - 1f);
			
			return maxSteepness / normalizationFactor;
		}
		
		
		private TerrainEdge findEdge(TerrainTile neighbor)
		{
			TerrainEdge edge = new TerrainEdge(this, neighbor);
			
			return edge;
		}
		
		
		/// <summary>
		/// Gets the edge between this terrain and the given terrain
		/// </summary>
		/// <returns>The edge.</returns>
		/// <param name="neighbors">Neighbors.</param>
		public float[] getEdge(TerrainTile neighbor)
		{
			float[] edge = new float[heightMapResolution];
			
			TerrainEdge terrainEdge = findEdge(neighbor);
			
			if(terrainEdge.edge != null)
			{
			
				//Construct our array which represents the edge
				for(int i = 0; i < heightMapResolution; i++)
				{
					//Based on the rules we defined earlier we'll move along an edge
					Vector2 edgePoint = new Vector2();
					
					if(terrainEdge.incrementX)
					{
						edgePoint = new Vector2(i, terrainEdge.startY);
					}
					else if(terrainEdge.incrementY)
					{
						edgePoint = new Vector2(terrainEdge.startX, i);
					}
					
					//In order to stitch the edges, we'll have to make the edge match the lower resolution terrain's edges.
					//We'll do this by taking the factor we found earlier, which represents the number of ratio of points between the two terrains
					//where the mod of i divided by this factor is 0, the heights on the terrain should line up.
					//If we make a smooth line from mod0 point mod0 point, the high resolution edge should match the low resolution edge. 
					
					edge[i] = getHeight((int)edgePoint.x, (int)edgePoint.y);
				}
			}
			
			return edge;
		}
		
		public float[] getActualEdge(TerrainTile neighbor)
		{
			float[,] actualHeights = UnityTerrain.terrainData.GetHeights(0,0,heightMapResolution, heightMapResolution);
		
			float[] edge = new float[heightMapResolution];
			
			TerrainEdge terrainEdge = findEdge(neighbor);
			
			if(terrainEdge.edge != null)
			{
				//Construct our array which represents the edge
				for(int i = 0; i < heightMapResolution; i++)
				{
					//Based on the rules we defined earlier we'll move along an edge
					Vector2 edgePoint = new Vector2();
					
					if(terrainEdge.incrementX)
					{
						edgePoint = new Vector2(i, terrainEdge.startY);
					}
					else if(terrainEdge.incrementY)
					{
						edgePoint = new Vector2(terrainEdge.startX, i);
					}
					
					//In order to stitch the edges, we'll have to make the edge match the lower resolution terrain's edges.
					//We'll do this by taking the factor we found earlier, which represents the number of ratio of points between the two terrains
					//where the mod of i divided by this factor is 0, the heights on the terrain should line up.
					//If we make a smooth line from mod0 point mod0 point, the high resolution edge should match the low resolution edge. 
					
					edge[i] = actualHeights[(int)edgePoint.x, (int)edgePoint.y];
				}
			}
			return edge;
		}
		
		public void setEdge(float[] heights, TerrainTile neighbor)
		{
			string calcedEdge = "";
			
			foreach(float height in heights)
			{
				calcedEdge += height + ",";
			}
			
			UnityEngine.Debug.Log("New edge: " + calcedEdge);
		
			lock(stitchLock)
			{
				TerrainEdge terrainEdge = findEdge(neighbor);
			
				float[,] stitchedHeights = (float[,])heightMap.Clone();
				
				//Construct our array which represents the edge
				for(int i = 0; i < heightMapResolution; i++)
				{
					//Based on the rules we defined earlier we'll move along an edge
					Vector2 edgePoint = new Vector2();
					
					if(terrainEdge.incrementX)
					{
						edgePoint = new Vector2(i, terrainEdge.startY);
					}
					else if(terrainEdge.incrementY)
					{
						edgePoint = new Vector2(terrainEdge.startX, i);
					}
					
					//In order to stitch the edges, we'll have to make the edge match the lower resolution terrain's edges.
					//We'll do this by taking the factor we found earlier, which represents the number of ratio of points between the two terrains
					//where the mod of i divided by this factor is 0, the heights on the terrain should line up.
					//If we make a smooth line from mod0 point mod0 point, the high resolution edge should match the low resolution edge. 
					
					stitchedHeights[(int)edgePoint.x, (int)edgePoint.y] = heights[i];
				}
								
				UnityTerrain.terrainData.SetHeightsDelayLOD(0,0,stitchedHeights);
			}
			
			float[] newEdge = getEdge(neighbor);
			
			string edgeString = "";
			
			foreach(float height in newEdge)
			{
				edgeString += height + ",";
			}
			
			UnityEngine.Debug.Log("Applied: " + edgeString);
			UnityEngine.Debug.Log("-------------------------------------");
		}
		
		public void resetEdge(TerrainTile tile)
		{
			savedEdges[tile] = getEdge(tile);
		
			float[] edge = new float[heightMapResolution];
			for(int i = 0; i < edge.Length; i++)
			{
				edge[i] = 1;
			}
			
			setEdge(edge, tile);
		}
		
		public void restoreEdge(TerrainTile tile)
		{
			float[] savedEdge;
			
			if(savedEdges.TryGetValue(tile, out savedEdge))
			{
				setEdge(savedEdge, tile);
			}
		}
		
		public void refreshTerrain()
		{
			Terrain oldTerrain = (Terrain)this.unityGameObject.GetComponent(typeof(Terrain));
			GameObject.DestroyImmediate(oldTerrain);
			
			TerrainCollider oldCollider = (TerrainCollider)this.unityGameObject.GetComponent(typeof(TerrainCollider));
			GameObject.DestroyImmediate(oldCollider);
			
			this.unityGameObject.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)this.unityGameObject.GetComponent(typeof(Terrain));
			
			this.unityGameObject.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)terrain.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
			
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = heightMapResolution;
			terrainData.size = WorldTerrain.dataSize;
			
			terrainData.alphamapResolution = splatMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeights(0,0, heightMap);
			
			terrain.terrainData = terrainData;
			
			terrainData.SetAlphamaps(0, 0, splatData);
		}
		
		public void unload()
		{
			GameObject.DestroyImmediate(unityGameObject);
			if(water != null)
			{
				GameObject.DestroyImmediate(water);
			}
		}
		
		public void load()
		{
			GameObject newTile = new GameObject();
			
			newTile.name = tileName;
			
			newTile.AddComponent(typeof(Terrain));
			Terrain terrain = (Terrain)newTile.GetComponent(typeof(Terrain));
			
			terrain.castShadows = false;
			
			newTile.AddComponent(typeof(TerrainCollider));
			TerrainCollider collider = (TerrainCollider)newTile.GetComponent(typeof(TerrainCollider));
			
			TerrainData terrainData = new TerrainData();
			
			terrainData.thickness = 1000;
						
			terrain.terrainData = terrainData;
			collider.terrainData = terrainData;
			
			terrainData.heightmapResolution = heightMapResolution;
			terrainData.size = WorldTerrain.dataSize;
			
			terrainData.alphamapResolution = splatMapResolution;
			
			generateTerrainTexture(terrainData);
			
			terrainData.SetHeightsDelayLOD(0,0,heightMap);
			
			terrainData.SetAlphamaps(0, 0, splatData);
			
			this.unityGameObject = newTile;
			
			if(hasWater)
			{
				water = GameObject.Instantiate(WorldTerrain.waterPrefab);
				water.transform.position = new Vector3(terrain.transform.position.x + WorldTerrain.tileSize/2, WorldTerrain.ceilingHeight*WorldTerrain.sea_level, terrain.transform.position.z + WorldTerrain.tileSize/2);
				water.transform.localScale = new Vector3(WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f,WorldTerrain.tileSize/10.0f);
				
				water.transform.SetParent(newTile.transform);
				
				containedObjects.Add(water);
			}
			
			updatePosition();
			
			stitchNeighbors();			
			setNeighbors();
		}
		
		private void generateTerrainTexture(TerrainData data)
		{
			SplatPrototype[] texture = new SplatPrototype[4];
			Texture2D sand = (Texture2D)Resources.Load("SandAlbedo"); 
			texture[0] = new SplatPrototype();
			texture[0].texture = sand;
			
			Texture2D grass = (Texture2D)Resources.Load("GrassHillAlbedo"); 
			texture[1] = new SplatPrototype();
			texture[1].texture = grass;
			
			Texture2D rockygrass = (Texture2D)Resources.Load("GrassRockyAlbedo"); 
			texture[2] = new SplatPrototype();
			texture[2].texture = rockygrass;
			
			Texture2D rockycliff = (Texture2D)Resources.Load("CliffAlbedoSpecular"); 
			texture[3] = new SplatPrototype();
			texture[3].texture = rockycliff;
			
			data.splatPrototypes = texture;
		}
		
		public void stepUpHeightMapResolution()
		{
			int curRes = heightMapResolution;
			
			if(curRes < WorldTerrain.heightMapResolution)
			{
				int newRes = (curRes - 1)*2 + 1;
				
				float?[,] newHeightMap = new float?[newRes,newRes];
				
				//Loop through the current height map and populate known heights
				for (int y = 0; y < heightMapResolution; y++)
				{
					for (int x = 0; x < heightMapResolution; x++)
					{
						float height = heightMap[x,y];
						
						newHeightMap[x*2, y*2] = height;
					}
				}
				
				//Now loop through the new height map
				for (int y = 0; y < heightMapResolution; y++)
				{
					for (int x = 0; x < heightMapResolution; x++)
					{
						float? height = newHeightMap[x,y];
						
						if(height == null)
						{
							generateHeight(x,y,newRes);
						}
					}
				}
			}
		}
		
		private float generateHeight(int x, int y, int resolution)
		{
			int heightRatio = (WorldTerrain.heightMapResolution - 1)/(resolution - 1);
		
			double xCoord = ((double)(x * heightRatio) + ((WorldTerrain.heightMapResolution - 1) * ((double)position.y))) / (double)WorldTerrain.noiseScale;
			double yCoord = ((double)(y * heightRatio) + ((WorldTerrain.heightMapResolution - 1) * ((double)position.x))) / (double)WorldTerrain.noiseScale;
			return (float)((module.GetValue(xCoord,yCoord, 1)));
		}
		
		public void generateComplexHeightMap()
		{
			Stopwatch timer = new Stopwatch();
			timer.Start();
			
			float[,] loadedHeights = tryLoadHeightMap();
		
			float[,] heights = new float[heightMapResolution, heightMapResolution];
			
			int heightRatio = (WorldTerrain.heightMapResolution - 1)/(heightMapResolution - 1);
			
			if(loadedHeights == null || loadedHeights.GetLength(0) != heightMapResolution || loadedHeights.GetLength(1) != heightMapResolution)
			{
				for (int y = 0; y < heightMapResolution; y++)
				{
					for (int x = 0; x < heightMapResolution; x++)
					{
						heights[x,y] = generateHeight(x,y, heightMapResolution);
					}
				}
				
				trySaveHeightMap(heights);
			}
			else
			{
				heights = loadedHeights;
			}
			
				heightMap = heights;
				highestResolutionHeightMap = heightMap;
				timer.Stop();
				getMinAltitude();
		}
		
		private void getMinAltitude()
		{
			foreach(float height in heightMap)
			{
				if(minAltitude > height)
				{
					minAltitude = height;
				}	
			}
		}
		
		private float[,,] tryLoadSplatMap()
		{
			float[,,] data = null;
			
			string filename = WorldTerrain.resourcesPath + @"\splatMapCache\" + tileName + "splatmap.dat";
			if(File.Exists(filename))
			{
				using (FileStream stream = File.Open(filename,FileMode.Open)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					
					// Deserialize the hashtable from the file and  
					// assign the reference to the local variable.
					data = (float[,,]) formatter.Deserialize(stream);
				}
			}
			
			return data;
		}
		
		private void trySaveSplatMap(float[,,] heights)
		{
			if(enableCaching)
			{
				string filename = WorldTerrain.resourcesPath + @"\splatMapCache\" + tileName + "splatmap.dat";
				if(File.Exists(filename))
				{
					File.Delete(filename);
				}
				using (FileStream stream = File.Create(filename)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					formatter.Serialize(stream, heights);
					stream.Close();
				}
			}
		}
		
		private float[,] tryLoadHeightMap()
		{
			float[,] heights = null;
		
			string filename = WorldTerrain.resourcesPath + @"\heightMapCache\" + tileName + "heightmap.dat";
			if(File.Exists(filename))
			{
				using (FileStream stream = File.Open(filename,FileMode.Open)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					
					heights = (float[,]) formatter.Deserialize(stream);
				}
			}
			
			return heights;
		}
		
		private void trySaveHeightMap(float[,] heights)
		{
			if(enableCaching)
			{
				string filename = WorldTerrain.resourcesPath + @"\heightMapCache\" + tileName + "heightmap.dat";
				if(File.Exists(filename))
				{
					File.Delete(filename);
				}
				using (FileStream stream = File.Create(filename)) 
				{
					BinaryFormatter formatter = new BinaryFormatter();
					formatter.Serialize(stream, heights);
					stream.Close();
				}
			}
		}
		
		public void generateSplatMap()
		{
			// Splatmap data is stored internally as a 3d array of floats, so declare a new empty array ready for your custom splatmap data:
			float[, ,] splatmapData = new float[splatMapResolution, splatMapResolution, alphaLayers];
			
			float[,,] loadedSplatmapData = tryLoadSplatMap();
			
			if(loadedSplatmapData == null || loadedSplatmapData.GetLength(0) != splatMapResolution || loadedSplatmapData.GetLength(1) != splatMapResolution || loadedSplatmapData.GetLength(2) != alphaLayers)
			{
				for (int y = 0; y < splatMapResolution; y++)
				{
					for (int x = 0; x < splatMapResolution; x++)
					{
						// Normalise x/y coordinates to range 0-1 
						float y_01 = (float)y/(float)splatMapResolution;
						float x_01 = (float)x/(float)splatMapResolution;
						
						int equivX = Mathf.RoundToInt(x_01 * heightMapResolution);
						int equivY = Mathf.RoundToInt(y_01 * heightMapResolution);
						
						// Sample the height at this location (note GetHeight expects int coordinates corresponding to locations in the heightmap array)
						float height = getHeight(equivX,equivY);
						
						// Calculate the normal of the terrain (note this is in normalised coordinates relative to the overall terrain dimensions)
						//Vector3 normal = terrainData.GetInterpolatedNormal(y_01,x_01);
						
						// Calculate the steepness of the terrain
						float steepness = getSteepness(equivX, equivY);
						
						// Setup an array to record the mix of texture weights at this point
						float[] splatWeights = new float[alphaLayers];
						
						// CHANGE THE RULES BELOW TO SET THE WEIGHTS OF EACH TEXTURE ON WHATEVER RULES YOU WANT
						
						float cliffThreshhold = 0.009f;
						
						SplatMapComparator[] heightComparators = WorldTerrain.heightTextureComparators.Values.ToArray();
						//Height weights
						for(int i = 0; i < heightComparators.Length; i++)
						{
							SplatMapComparator comparator = heightComparators[i];
							
							float weight = comparator.calculateValue(height);
							splatWeights[i] = weight;
						}
						
						SplatMapComparator[] steepnessComparators = WorldTerrain.steepnessTextureComparators.Values.ToArray();
						//Height weights
						for(int i = 0; i < steepnessComparators.Length; i++)
						{
							SplatMapComparator comparator = steepnessComparators[i];
							
							float weight = comparator.calculateValue(steepness);
							if(WorldTerrain.steepnessTextureComparators["cliff"] != comparator)
							{
								splatWeights[i] = splatWeights[i] - weight;
							}
							else
							{
								if(splatWeights[i] < weight)
								{
									splatWeights[i] = weight;
								}
							}
						}
						
						float weightSum = splatWeights.Sum();
						
						// Loop through each terrain texture
						for(int i = 0; i<alphaLayers; i++)
						{
							// Assign this point to the splatmap array
							splatmapData[x, y, i] = splatWeights[i]/weightSum;
						}
					}
				}
				
				trySaveSplatMap(splatmapData);
			}
			else
			{
				splatmapData = loadedSplatmapData;
			}
			
			splatData = splatmapData;
		}
		
		public void stitchNeighbors()
		{
			List<string> neighbors = new List<string>();
			
			int tileX = (int)position.x;
			int tileY = (int)position.y;
			
			neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1));
			neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY));
			neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1));
			
			List<TerrainTile> terrains = new List<TerrainTile>();
			
			foreach(string neighbor in neighbors)
			{
				TerrainTile neighborTile = null;
				if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
				{
					terrains.Add(neighborTile);
				}
				else
				{
					terrains.Add(null);
				}
			}
			
			if(terrains.Count == 4)
			{
				if(terrains[0] != null)
				{
					if(terrains[0].heightMapResolution < heightMapResolution)
					{
						stitchTerrainBorders(terrains[0]);
					}
					else if(terrains[0].heightMapResolution > heightMapResolution)
					{
						terrains[0].stitchTerrainBorders(this);
					}
				}
				if(terrains[1] != null)
				{
					if(terrains[1].heightMapResolution < heightMapResolution)
					{
						stitchTerrainBorders(terrains[1]);
					}
					else if(terrains[1].heightMapResolution > heightMapResolution)
					{
						terrains[1].stitchTerrainBorders(this);
					}
				}
				if(terrains[2] != null)
				{
					if(terrains[2].heightMapResolution < heightMapResolution)
					{
						stitchTerrainBorders(terrains[2]);
					}
					else if(terrains[2].heightMapResolution > heightMapResolution)
					{
						terrains[2].stitchTerrainBorders(this);
					}
				}
				if(terrains[3] != null)
				{
					if(terrains[3].heightMapResolution < heightMapResolution)
					{
						stitchTerrainBorders(terrains[3]);
					}
					else if(terrains[3].heightMapResolution > heightMapResolution)
					{
						terrains[3].stitchTerrainBorders(this);
					}
				}	
			}
		}
		
		public void setNeighbors()
		{
			try
			{
				List<string> neighbors = new List<string>();
				
				int tileX = (int)position.x;
				int tileY = (int)position.y;
				
				neighbors.Add(WorldTerrain.getTerrainName(tileX - 1, tileY));
				neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY + 1));
				neighbors.Add(WorldTerrain.getTerrainName(tileX + 1, tileY));
				neighbors.Add(WorldTerrain.getTerrainName(tileX, tileY - 1));
				
				List<TerrainTile> terrains = new List<TerrainTile>();
				
				foreach(string neighbor in neighbors)
				{
					TerrainTile neighborTile = null;
					if(WorldTerrain.terrainMap.TryGetValue(neighbor, out neighborTile))
					{
						terrains.Add(neighborTile);
					}
					else
					{
						terrains.Add(null);
					}
				}
				
				if(terrains.Count == 4)
				{
					Terrain tileTerrain = UnityTerrain;
					
					Terrain left = null;
					Terrain top = null;
					Terrain right = null;
					Terrain bottom = null;
					
					if(terrains[0] != null && terrains[0].heightMapResolution == heightMapResolution)
					{
						left = terrains[0].UnityTerrain;
						
						if(!terrains[0].neighbors.Contains (this))
						{
							terrains[0].setNeighbors();
						}
					}
					if(terrains[1] != null && terrains[1].heightMapResolution == heightMapResolution)
					{
						top = terrains[1].UnityTerrain;
						
						if(!terrains[1].neighbors.Contains (this))
						{
							terrains[1].setNeighbors();
						}
					}
					if(terrains[2] != null && terrains[2].heightMapResolution == heightMapResolution)
					{
						right = terrains[2].UnityTerrain;
						
						if(!terrains[2].neighbors.Contains (this))
						{
							terrains[2].setNeighbors();
						}
					}
					if(terrains[3] != null && terrains[3].heightMapResolution == heightMapResolution)
					{
						bottom = terrains[3].UnityTerrain;
						
						if(!terrains[3].neighbors.Contains (this))
						{
							terrains[3].setNeighbors();
						}
					}
					
					this.neighbors = terrains.ToArray();
					
					tileTerrain.SetNeighbors(left, top, right, bottom);
				}
			}
			catch(StackOverflowException ex)
			{
				UnityEngine.Debug.Log(ex.Message);
			}
		}
		
		public void clearNeighbors()
		{
			UnityTerrain.SetNeighbors(null,null,null,null);
			
			neighbors = new TerrainTile[4];
		}
		
		public void stitchTerrainBorders(TerrainTile tile)
		{
			//This number will represent how frequently the heights match up for the two edges
			int factor = (heightMapResolution - 1)/(tile.heightMapResolution - 1);	
			
			float[] highResEdge = getActualEdge(tile);
			float[] stitchedEdge = new float[heightMapResolution];

			for(int i = 0; i < heightMapResolution; i++)
			{
				if(i%factor != 0)
				{
					int mod = i%factor;
					
					float prevHeight = highResEdge[i-1];
					float nextHeight = highResEdge[i+1];
					
					float newValue = (prevHeight + nextHeight) / 2f;
					
					stitchedEdge[i] = newValue;
				}
				else
				{
					stitchedEdge[i] = highResEdge[i];
				}
			}
			
			string edgeString = "";
			
			foreach(float height in highResEdge)
			{
				edgeString += height + ",";
			}
			
			string calcedEdge = "";
			
			foreach(float height in stitchedEdge)
			{
				calcedEdge += height + ",";
			}
						
			setEdge(stitchedEdge, tile);
			
			if(!stitchedTo.Contains(tile))
			{
				stitchedTo.Add(tile);
			}
			
			tile.stitchedTime = DateTime.Now;
			stitchedTime = DateTime.Now;
			
			UnityTerrain.ApplyDelayedHeightmapModification();
			tile.UnityTerrain.ApplyDelayedHeightmapModification();
		}
		
		private void outputHeightMapToCSV(string heightmapName)
		{
			FileInfo heightMapFile = new FileInfo(@"C:\Users\Jeffery\Desktop\tileComparisons\" + "highResAltered[" + (int)position.x + "][" + (int)position.y + "]");
			
			if(!heightMapFile.Exists)
			{
				using(TextWriter writer = heightMapFile.CreateText())
				{
					for(int y = 0; y < heightMapResolution; y++)
					{
						for(int x = 0; x < heightMapResolution; x++)
						{
							writer.Write(heightMap[x,y]);
							if(x != heightMapResolution - 1)
							{
								writer.Write(",");
							}
						}
						writer.WriteLine();
					}
				}
			}
		}
		
		public void updatePosition()
		{	
			Vector3 originOffset = new Vector3(WorldTerrain.origin.x * WorldTerrain.size, 0, WorldTerrain.origin.y * WorldTerrain.size);
			
			Vector3 gridPosition = new Vector3(position.x * WorldTerrain.size, 0, position.y * WorldTerrain.size);
		
			unityGameObject.transform.position = gridPosition - originOffset;
		}
	}
}

