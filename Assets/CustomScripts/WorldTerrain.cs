//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using LibNoise.Generator;
using LibNoise.Operator;
using AssemblyCSharp;

namespace AssemblyCSharp
{
	public class WorldTerrain
	{
		//These define the maximum resolutions for heightmaps and alphamaps(splatmap)
		public static int heightMapResolution;
		public static int alphaMapResolution;
		public static int tileSize;
		public static int ceilingHeight;
		
		public static int noiseScale;
		public static int seed;
		
		public static Vector3 dataSize;
		public static float size;
		
		public static GameObject waterPrefab;
		
		public static float sea_level = 0.3f;
		
		public static string resourcesPath;
		
		public static GameObject player;
		
		private static Queue<TerrainTile> refreshQueue = new Queue<TerrainTile>();
		private static DateTime lastRefresh;
		private static int refreshInterval = 1000;
		
		private static Queue<TerrainTile> stitchQueue = new Queue<TerrainTile>();
		private static DateTime lastStitch;
		private static int stitchInterval = 1000;
				
		public static Vector2 origin = new Vector2(0,0);
		
		#region TextureRanges
		//These ranges define how various textures will be expressed in terrain based on altitude
		//Between a given Min and Max, the texture will be expressed at 100%.
		//Then the texture will go from 100% to 0% in the distance of the Blend value. 
		
		//Example: At Sea_Level, sand will be expressed at 100%. At Sea_Level + sandBlend, it will be expressed at 0%. At Sea_Level + sandBlend/2 it will be expressed at 50%;
		
		#region heighTextureRanges
		static float sandHeightMin = 0f;
		static float sandHeightMax = sea_level * 1.1f;
		static float sandHeightBlend = 0.050f;
		
		static float grassHeightMin = sandHeightMax;
		static float grassHeightMax = 0.50f;
		static float grassHeightBlend = 0.05f;
		
		static float rockyGrassHeightMin = grassHeightMax;
		static float rockyGrassHeightMax = 0.90f;
		static float rockyGrassHeightBlend = 0.05f;
		
		static float cliffHeightMin = rockyGrassHeightMax;
		static float cliffHeightMax = 1.0f;
		static float cliffHeightBlend = 0.025f;
		
		public static Dictionary<string,SplatMapComparator> heightTextureComparators = new Dictionary<string, SplatMapComparator>() {
			{"sand", new SplatMapComparator(sandHeightMax, sandHeightMin, sandHeightBlend)},
			{"grass", new SplatMapComparator(grassHeightMax, grassHeightMin, grassHeightBlend)},
			{"rockyGrass", new SplatMapComparator(rockyGrassHeightMax, rockyGrassHeightMin, rockyGrassHeightBlend)},
			{"cliff", new SplatMapComparator(cliffHeightMax, cliffHeightMin, cliffHeightBlend)}
		};
		#endregion
		
		#region steepnessTextureRanges
		static float nonCliffSteepnessMin = 0f;
		static float nonCliffSteepnessMax = cliffSteepnessMin;
		static float nonCliffSteepnessBlend = cliffSteepnessBlend;
		
		static float cliffSteepnessMin = 0.0006f;
		static float cliffSteepnessMax = 1.0f;
		static float cliffSteepnessBlend = 0.0002f;
		
		public static Dictionary<string,SplatMapComparator> steepnessTextureComparators = new Dictionary<string, SplatMapComparator>() {
			{"sand", new SplatMapComparator(nonCliffSteepnessMax, nonCliffSteepnessMin, nonCliffSteepnessBlend)},
			{"grass", new SplatMapComparator(nonCliffSteepnessMax, nonCliffSteepnessMin, nonCliffSteepnessBlend)},
			{"rockyGrass", new SplatMapComparator(nonCliffSteepnessMax, nonCliffSteepnessMin, nonCliffSteepnessBlend)},
			{"cliff", new SplatMapComparator(cliffSteepnessMax, cliffSteepnessMin, cliffSteepnessBlend)}
		};
		#endregion
		
		#endregion
	
		public WorldTerrain (GameObject playerObject)
		{
			player = playerObject;
		}
		
		private void stitch()
		{
			foreach(TerrainTile tile in WorldTerrain.terrainMap.Values)
			{
				foreach(TerrainTile neighbor in tile.neighbors)
				{
					if(neighbor != null && neighbor.heightMapResolution < tile.heightMapResolution && neighbor.neighbors.Contains(tile) && !tile.stitchedTo.Contains(neighbor))
					{
						tile.stitchTerrainBorders(neighbor);
						break;
					}
				}
			}
		}
		
		public static Dictionary<string, TerrainTile> terrainMap = new Dictionary<string, TerrainTile>();
		
		public static Dictionary<string, TerrainTile> pendingTerrain = new Dictionary<string, TerrainTile>();
		
		public static string getTerrainName(int x, int y){
			string terrainName = "Terrain[" + x + "," + y + "]";
			return terrainName;
		}
		
		public static Vector2 getGridCoordinate(Vector3 position){
			Vector2 coordinate = new Vector2 ();
			
			coordinate.x = Mathf.FloorToInt (position.x / (size)) + origin.x;
			coordinate.y = Mathf.FloorToInt (position.z / (size)) + origin.y;
			
			return coordinate;
		}
		
		public static int getGridDistance(Vector2 pos1, Vector2 pos2){
			return Mathf.FloorToInt(Mathf.Sqrt ( Mathf.Pow((pos1.x - pos2.x),2) + Mathf.Pow((pos1.y - pos2.y),2)));
		}
		
		public static int getGridDistanceToPlayer(Vector2 pos)
		{
			return getGridDistance(pos, getGridCoordinate(player.transform.position));
		}
		
		public struct LocalCoordinate
		{
			public Vector2 tileAddress;
			public Vector2 localCoordinate;
		}
		
		public static void queueTerrainForStitch(TerrainTile tile)
		{
			bool needsStitch = false;
			
			foreach(TerrainTile neighbor in tile.neighbors)
			{
				if(neighbor != null && neighbor.heightMapResolution < tile.heightMapResolution && !tile.stitchedTo.Contains(neighbor))
				{
					if(!stitchQueue.Contains(tile))
					{
						needsStitch = true;
					}
				}
			}
			
			if(needsStitch)
			{
				stitchQueue.Enqueue(tile);
			}
		}
		
		public static void processStitchQueue()
		{
			double timeSinceLastStitch = DateTime.Now.Subtract(lastStitch).TotalMilliseconds;
			if((lastStitch == null || timeSinceLastStitch >= stitchInterval) && stitchQueue.Count > 0)
			{
				TerrainTile tile = stitchQueue.Dequeue();
				
				tile.stitchNeighbors();
												
				foreach(TerrainTile stitched in tile.stitchedTo)
				{
					//queueTerrainForRefresh(stitched);
				}
				
				//queueTerrainForRefresh(tile);
				
				
				lastStitch = DateTime.Now;
			}
		}
		
		public static void queueTerrainForRefresh(TerrainTile tile)
		{
			if(!refreshQueue.Contains(tile))
			{
				refreshQueue.Enqueue(tile);
			}
		}
		
		public static void processRefreshQueue()
		{
			double timeSinceLastRefresh = DateTime.Now.Subtract(lastRefresh).TotalMilliseconds;
			
			if((lastRefresh == null || timeSinceLastRefresh >= refreshInterval) && refreshQueue.Count > 0)
			{	
				if(refreshQueue.Peek().stitchedTime != null && DateTime.Now.Subtract(refreshQueue.Peek().stitchedTime).TotalMilliseconds > refreshInterval)
				{ 
					TerrainTile tile = refreshQueue.Dequeue();
					
					//tile.refreshTerrain();
					tile.UnityTerrain.ApplyDelayedHeightmapModification();
					
					//tile.setNeighbors();
					
					tile.UnityTerrain.Flush();
					
					lastRefresh = DateTime.Now;
				}
			}
		}
		
		/// <summary>
		/// Converts worldspace coordinates to local coordinates in a tile
		/// Since different aspects of a tile may have different widths,
		/// width must be specified
		/// </summary>
		/// <returns>The to local.</returns>
		/// <param name="position">Position.</param>
		/// <param name="width">Width.</param>
		public static LocalCoordinate WorldToLocal(Vector3 position, int width)
		{
			LocalCoordinate result = new LocalCoordinate();
			
			result.tileAddress = getGridCoordinate(position);
			
			float remainderX = position.x/size;
			float remainderY = position.z/size;
			
			float normalizedX = Mathf.Abs(remainderX - Mathf.Floor(remainderX));
			float normalizedY = Mathf.Abs(remainderY - Mathf.Floor(remainderY));
			
			float relativeX = Mathf.FloorToInt(normalizedX * (float)width);
			float relativeY = Mathf.FloorToInt(normalizedY * (float)width);
			
			result.localCoordinate.x = relativeY;
			result.localCoordinate.y = relativeX;
			
			return result;
		}
		
		/// <summary>
		/// Converts worldspace coordinates to local coordinates in a tile
		/// Since different aspects of a tile may have different widths,
		/// width must be specified
		/// </summary>
		/// <returns>The to local.</returns>
		/// <param name="position">Position.</param>
		/// <param name="width">Width.</param>
		public static LocalCoordinate WorldToLocalExact(Vector3 position, int width)
		{
			LocalCoordinate result = new LocalCoordinate();
			
			result.tileAddress = getGridCoordinate(position);
			
			float remainderX = position.x/size;
			float remainderY = position.z/size;
			
			float normalizedX = Mathf.Abs(remainderX - Mathf.Floor(remainderX));
			float normalizedY = Mathf.Abs(remainderY - Mathf.Floor(remainderY));
			
			float relativeX = normalizedX * (float)width;
			float relativeY = normalizedY * (float)width;
			
			result.localCoordinate.x = relativeX;
			result.localCoordinate.y = relativeY;
			
			return result;
		}
		
		public static Vector2 LocalToWorld(LocalCoordinate localCoordinate)
		{
			Vector2 result = new Vector2();
			
			float originXoffset = ((localCoordinate.tileAddress.x - WorldTerrain.origin.x) * WorldTerrain.size);
			float originYoffset = ((localCoordinate.tileAddress.y - WorldTerrain.origin.y) * WorldTerrain.size);
			
			result.x = localCoordinate.localCoordinate.x + originXoffset;
			result.y = localCoordinate.localCoordinate.y + originYoffset;
			
			return result;
		}
	}
}

