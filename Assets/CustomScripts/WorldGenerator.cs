//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using LibNoise.Operator;
using LibNoise.Generator;

namespace AssemblyCSharp
{
	public class WorldGenerator
	{
		int width = 4096;
		int height = 2048;
	
		int seed = 0;
		
		// Minimum elevation on the planet, in meters.  This value is approximate.
		const double minElev = -8192.0;
		const double maxElev = 8192.0;
		
		// Frequency of the planet's continents.  Higher frequency produces smaller,
		// more numerous continents.  This value is measured in radians.
		const double continent_frequency = 1.0;
		
		// Lacunarity of the planet's continents.  Changing this value produces
		// slightly different continents.  For the best results, this value should
		// be random, but close to 2.0.
		const double continent_lacunarity = 2.208984375;
		
		const double mountain_lacunarity = 2.142578125;
		
		const double hills_lacunarity = 2.162109375;
		
		const double plains_lacunarity = 2.314453125;
		
		const double badlands_lacunarity = 2.212890625;
		
		// Specifies the "twistiness"
		const double mountains_twist = 1.0;
		const double hills_twist = 1.0;
		const double badlands_twist = 1.0;
		
		// Specifies the planet's sea level.  This value must be between -1.0
		// (minimum planet elevation) and +1.0 (maximum planet elevation.)
		const double sea_level = 0.0;
		
		// Specifies the level on the planet in which continental shelves appear.
		// This value must be between -1.0 (minimum planet elevation) and +1.0
		// (maximum planet elevation), and must be less than SEA_LEVEL.
		const double shelf_level = -0.375;
		
		// Determines the amount of mountainous terrain that appears on the
		// planet.  Values range from 0.0 (no mountains) to 1.0 (all terrain is
		// covered in mountains).  Mountainous terrain will overlap hilly terrain.
		// Because the badlands terrain may overlap parts of the mountainous
		// terrain, setting MOUNTAINS_AMOUNT to 1.0 may not completely cover the
		// terrain in mountains.
		const double mountains_amount = 0.5;
		
		// Determines the amount of hilly terrain that appears on the planet.
		// Values range from 0.0 (no hills) to 1.0 (all terrain is covered in
		// hills).  This value must be less than MOUNTAINS_AMOUNT.  Because the
		// mountainous terrain will overlap parts of the hilly terrain, and
		// the badlands terrain may overlap parts of the hilly terrain, setting
		// HILLS_AMOUNT to 1.0 may not completely cover the terrain in hills.
		const double hills_amount = (1.0 + mountains_amount)/2.0;
		
		// Determines the amount of badlands terrain that covers the planet.
		// Values range from 0.0 (no badlands) to 1.0 (all terrain is covered in
		// badlands.)  Badlands terrain will overlap any other type of terrain.
		const double badlands_amount = 0.03125;
		
		// Offset to apply to the terrain type definition.  Low values (< 1.0) cause
		// the rough areas to appear only at high elevations.  High values (> 2.0)
		// cause the rough areas to appear at any elevation.  The percentage of
		// rough areas on the planet are independent of this value.
		const double TERRAIN_OFFSET = 1.0;
		
		// Specifies the amount of "glaciation" on the mountains.  This value
		// should be close to 1.0 and greater than 1.0.
		const double mountain_glaciation = 1.375;
		
		// Scaling to apply to the base continent elevations, in planetary elevation
		// units.
		const double cont_height_scale = (1.0 - sea_level) / 4.0;
		
		// Maximum depth of the rivers, in planetary elevation units.
		const double river_depth = 0.0234375;
		
		LibNoise.ModuleBase _module;
		
		#region Getters
		public LibNoise.ModuleBase Module
		{
			get
			{
				return _module;
			}
		}
		#endregion
		
		public WorldGenerator ()
		{
			#region Continent Base
			// 1: [Continent module]: This Perlin-noise module generates the continents.
			//    This noise module has a high number of octaves so that detail is
			//    visible at high zoom levels.
			Perlin baseContinent_pe0 = new Perlin();
			baseContinent_pe0.Seed = seed + 0;
			baseContinent_pe0.Frequency = continent_frequency;
			baseContinent_pe0.Persistence = 0.35;//0.5
			baseContinent_pe0.Lacunarity = continent_lacunarity;
			baseContinent_pe0.OctaveCount = 14;//14
			baseContinent_pe0.Quality = LibNoise.QualityMode.High;
			
			// 2: [Continent-with-ranges module]: Next, a curve module modifies the
			//    output value from the continent module so that very high values appear
			//    near sea level.  This defines the positions of the mountain ranges.
			Curve baseContinentCurve = new Curve(baseContinent_pe0);
			baseContinentCurve.Add(-2.0000 + sea_level,-1.625 + sea_level);
			baseContinentCurve.Add(-1.0000 + sea_level,-1.375 + sea_level);
			baseContinentCurve.Add( 0.0000 + sea_level,-0.375 + sea_level);
			baseContinentCurve.Add( 0.0625 + sea_level, 0.125 + sea_level);
			baseContinentCurve.Add( 0.1250 + sea_level, 0.250 + sea_level);
			baseContinentCurve.Add( 0.2500 + sea_level, 1.000 + sea_level);
			baseContinentCurve.Add( 0.5000 + sea_level, 0.250 + sea_level);
			baseContinentCurve.Add( 0.7500 + sea_level, 0.250 + sea_level);
			baseContinentCurve.Add( 1.0000 + sea_level, 0.500 + sea_level);
			baseContinentCurve.Add( 2.0000 + sea_level, 0.500 + sea_level);
			
			// 3: [Carver module]: This higher-frequency Perlin-noise module will be
			//    used by subsequent noise modules to carve out chunks from the mountain
			//    ranges within the continent-with-ranges module so that the mountain
			//    ranges will not be complely impassible.
			Perlin baseContinent_pe1 = new Perlin();
			baseContinent_pe1.Seed = seed + 1;
			baseContinent_pe1.Frequency = continent_frequency * 4.34275;
			baseContinent_pe1.Persistence = 0.4;
			baseContinent_pe1.Lacunarity = continent_lacunarity;
			baseContinent_pe1.OctaveCount = 11;
			baseContinent_pe1.Quality = LibNoise.QualityMode.High;
			
			// 4: [Scaled-carver module]: This scale/bias module scales the output
			//    value from the carver module such that it is usually near 1.0.  This
			//    is required for step 5.
			ScaleBias baseContinentScaleBias = new ScaleBias(baseContinent_pe1);
			baseContinentScaleBias.Scale = 0.375;
			baseContinentScaleBias.Bias = 0.625;
			
			// 5: [Carved-continent module]: This minimum-value module carves out chunks
			//    from the continent-with-ranges module.  It does this by ensuring that
			//    only the minimum of the output values from the scaled-carver module
			//    and the continent-with-ranges module contributes to the output value
			//    of this subgroup.  Most of the time, the minimum-value module will
			//    select the output value from the continents-with-ranges module since
			//    the output value from the scaled-carver module is usually near 1.0.
			//    Occasionally, the output value from the scaled-carver module will be
			//    less than the output value from the continent-with-ranges module, so
			//    in this case, the output value from the scaled-carver module is
			//    selected.
			Min baseContinentMin = new Min(baseContinentScaleBias, baseContinentCurve);
			
			// 6: [Clamped-continent module]: Finally, a clamp module modifies the
			//    carved-continent module to ensure that the output value of this
			//    subgroup is between -1.0 and 1.0.
			Clamp baseContinentDef = new Clamp(-1.0, 1.0, baseContinentMin);
			
			#endregion
			
			#region Continent Definition
			
			// 1: [Coarse-turbulence module]: This turbulence module warps the output
			//    value from the base-continent-definition subgroup, adding some coarse
			//    detail to it.
			Turbulence continentDef_tu0 = new Turbulence(baseContinentDef);
			continentDef_tu0.Seed = seed + 10;
			continentDef_tu0.Frequency = continent_frequency*15.25;
			continentDef_tu0.Power = continent_frequency/113.75;
			continentDef_tu0.Roughness = 13;
			
			// 2: [Intermediate-turbulence module]: This turbulence module warps the
			//    output value from the coarse-turbulence module.  This turbulence has
			//    a higher frequency, but lower power, than the coarse-turbulence
			//    module, adding some intermediate detail to it.
			Turbulence continentDef_tu1 = new Turbulence(continentDef_tu0);
			continentDef_tu1.Seed = seed + 11;
			continentDef_tu1.Frequency = continent_frequency*47.25;
			continentDef_tu1.Power = continent_frequency/433.75;
			continentDef_tu1.Roughness = 12;
			
			// 3: [Warped-base-continent-definition module]: This turbulence module
			//    warps the output value from the intermediate-turbulence module.  This
			//    turbulence has a higher frequency, but lower power, than the
			//    intermediate-turbulence module, adding some fine detail to it.
			Turbulence continentDef_tu2 = new Turbulence(continentDef_tu1);
			continentDef_tu2.Seed = seed + 12;
			continentDef_tu2.Frequency = continent_frequency * 5.25;//95.25
			continentDef_tu2.Power = continent_frequency * 1019.75;//1019.75
			continentDef_tu2.Roughness = 11;
			
			// 4: [Select-turbulence module]: At this stage, the turbulence is applied
			//    to the entire base-continent-definition subgroup, producing some very
			//    rugged, unrealistic coastlines.  This selector module selects the
			//    output values from the (unwarped) base-continent-definition subgroup
			//    and the warped-base-continent-definition module, based on the output
			//    value from the (unwarped) base-continent-definition subgroup.  The
			//    selection boundary is near sea level and has a relatively smooth
			//    transition.  In effect, only the higher areas of the base-continent-
			//    definition subgroup become warped; the underwater and coastal areas
			//    remain unaffected.
			Select continentDef = new Select(baseContinentDef, continentDef_tu1, baseContinentDef);
			continentDef.SetBounds(sea_level - 0.0375, sea_level + 1000.0375);
			continentDef.FallOff = 0.0625;
			
			#endregion
			
			#region Terrain Type
			// Module subgroup: terrain type definition (3 noise modules)
			//
			// This subgroup defines the positions of the terrain types on the planet.
			//
			// Terrain types include, in order of increasing roughness, plains, hills,
			// and mountains.
			//
			// This subgroup's output value is based on the output value from the
			// continent-definition group.  Rougher terrain mainly appears at higher
			// elevations.
			//
			// -1.0 represents the smoothest terrain types (plains and underwater) and
			// +1.0 represents the roughest terrain types (mountains).
			
			// 1: [Warped-continent module]: This turbulence module slightly warps the
			//    output value from the continent-definition group.  This prevents the
			//    rougher terrain from appearing exclusively at higher elevations.
			//    Rough areas may now appear in the the ocean, creating rocky islands
			//    and fjords.
			Turbulence terrainTypeDef_tu = new Turbulence(continentDef);
			terrainTypeDef_tu.Seed = seed + 20;
			terrainTypeDef_tu.Frequency = continent_frequency * 18.125;
			terrainTypeDef_tu.Power = continent_frequency / 20.59375 * TERRAIN_OFFSET;
			terrainTypeDef_tu.Roughness = 3;
			
			// 2: [Roughness-probability-shift module]: This terracing module sharpens
			//    the edges of the warped-continent module near sea level and lowers
			//    the slope towards the higher-elevation areas.  This shrinks the areas
			//    in which the rough terrain appears, increasing the "rarity" of rough
			//    terrain.
			Terrace terrainTypeDefTerrace = new Terrace(terrainTypeDef_tu);
			terrainTypeDefTerrace.ControlPoints.Add(-1.0);
			terrainTypeDefTerrace.ControlPoints.Add(shelf_level + sea_level/2.0);
			terrainTypeDefTerrace.ControlPoints.Add(1.0);
			
			ScaleBias terrainTypeDef = new ScaleBias(terrainTypeDefTerrace);
			terrainTypeDef.Scale = 0.75f;
			terrainTypeDef.Bias = -0.1f;
			
			#endregion
			
			#region High Mountainous Terrain
			// Module subgroup: high mountainous terrain (5 noise modules)
			//
			// This subgroup generates the mountainous terrain that appears at high
			// elevations within the mountain ridges.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			//
			
			// 1: [Mountain-basis-0 module]: This ridged-multifractal-noise module,
			//    along with the mountain-basis-1 module, generates the individual
			//    mountains.
			RidgedMultifractal mountainousHigh_rm0 = new RidgedMultifractal();
			mountainousHigh_rm0.Seed = seed + 40;
			mountainousHigh_rm0.Frequency = 5.0;//2371.0
			mountainousHigh_rm0.Lacunarity = mountain_lacunarity;
			mountainousHigh_rm0.OctaveCount = 4;//3
			mountainousHigh_rm0.Quality = LibNoise.QualityMode.High;
			
			// 2: [Mountain-basis-1 module]: This ridged-multifractal-noise module,
			//    along with the mountain-basis-0 module, generates the individual
			//    mountains.
			RidgedMultifractal mountainousHigh_rm1 = new RidgedMultifractal();
			mountainousHigh_rm1.Seed = seed + 41;
			mountainousHigh_rm1.Frequency = 8.0;//2341.0
			mountainousHigh_rm1.Lacunarity = mountain_lacunarity;
			mountainousHigh_rm1.OctaveCount = 4;//3
			mountainousHigh_rm1.Quality = LibNoise.QualityMode.High;
			
			// 3: [High-mountains module]: Next, a maximum-value module causes more
			//    mountains to appear at the expense of valleys.  It does this by
			//    ensuring that only the maximum of the output values from the two
			//    ridged-multifractal-noise modules contribute to the output value of
			//    this subgroup.
			Max mountainousHigh_ma = new Max(mountainousHigh_rm0, mountainousHigh_rm1);
			
			// 4: [Warped-high-mountains module]: This turbulence module warps the
			//    output value from the high-mountains module, adding some detail to it.
			Turbulence mountainousHigh = new Turbulence(mountainousHigh_ma);
			mountainousHigh.Seed = seed + 42;
			mountainousHigh.Frequency = 51.0;//31511.0
			mountainousHigh.Power = (1.0/180371.0 * mountains_twist)*525;
			mountainousHigh.Roughness = 6;
			
			#endregion
			
			ScaleBias mountainousHighScale = new ScaleBias(mountainousHigh);
			mountainousHighScale.Scale = 1.0;//0.775
			mountainousHighScale.Bias = 0.0;
			
			Add mountainAdd = new Add(mountainousHighScale, terrainTypeDef);
			
			Select mountainSelect = new Select(terrainTypeDef, mountainAdd, terrainTypeDef);
			mountainSelect.SetBounds(0.55, 2.0);
			mountainSelect.FallOff = 4.5;
			
			
			ScaleBias worldScale = new ScaleBias(mountainSelect);
			worldScale.Scale = 0.4;
			worldScale.Bias = 0.5;
			
			#region River Positions
			
			// Module group: river positions
			
			// Module subgroup: river positions (7 noise modules)
			//
			// This subgroup generates the river positions.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			/// 3: [Small-river-basis module]: This ridged-multifractal-noise module
			//     creates the small, shallow rivers.
			RidgedMultifractal riverPositions_rm1 = new RidgedMultifractal();
			riverPositions_rm1.Seed = seed + 101;
			riverPositions_rm1.Frequency = 2.25;
			riverPositions_rm1.Lacunarity = continent_lacunarity;
			riverPositions_rm1.OctaveCount = 1;
			riverPositions_rm1.Quality = LibNoise.QualityMode.High;
			
			
			// 4: [Small-river-curve module]: This curve module applies a curve to the
			//    output value from the small-river-basis module so that the ridges
			//    become inverted.  This creates the rivers.  This curve also compresses
			//    the edge of the rivers, producing a sharp transition from the land to
			//    the river bottom.
			Curve riverPositions_cu1 = new Curve(riverPositions_rm1);
			riverPositions_cu1.Add (-2.000,  2.0000);
			riverPositions_cu1.Add (-1.000,  1.5000);
			riverPositions_cu1.Add (-0.125,  1.4375);
			riverPositions_cu1.Add ( 0.000,  0.5000);
			riverPositions_cu1.Add ( 1.000,  0.2500);
			riverPositions_cu1.Add ( 2.000,  0.0000);
			
			// 6: [Warped-rivers module]: This turbulence module warps the output value
			//    from the combined-rivers module, which twists the rivers.  The high
			//    roughness produces less-smooth rivers.
			Turbulence riverPositions = new Turbulence(riverPositions_rm1);
			riverPositions.Seed = seed + 102;
			riverPositions.Frequency = 9.25;
			riverPositions.Power = (1.0/57.75);
			riverPositions.Roughness = 6;
			
			Clamp riverClamp = new Clamp(riverPositions);
			riverClamp.SetBounds(0.0, 0.5);
			
			Invert riverInvert = new Invert(riverClamp);
			
			Add riverAdd = new Add(riverInvert, new Const(0.35));
			
			#endregion
			
			//Only add rivers in where they appear, disregard the rest			
			Select riverSelect = new Select(worldScale, riverAdd, riverAdd);
			riverSelect.SetBounds(0.0, 0.25);
			riverSelect.FallOff = 3.0;
			
			//Only add rivers into the world when the altitude of the terrain is not ocean
			//or mountainous
			Select landSelect = new Select(worldScale, riverSelect, worldScale);
			landSelect.SetBounds(0.35, 0.80);
			landSelect.FallOff = 5.0;
			_module = landSelect;
			
		}
		
		
		
		
		
		
		
		
		
		
		
		
		private void ConstructDefaultModule()
		{
			#region Continent Base
			// 1: [Continent module]: This Perlin-noise module generates the continents.
			//    This noise module has a high number of octaves so that detail is
			//    visible at high zoom levels.
			Perlin baseContinent_pe0 = new Perlin();
			baseContinent_pe0.Seed = seed + 0;
			baseContinent_pe0.Frequency = continent_frequency;
			baseContinent_pe0.Persistence = 0.5;//0.5
			baseContinent_pe0.Lacunarity = continent_lacunarity;
			baseContinent_pe0.OctaveCount = 14;//14
			baseContinent_pe0.Quality = LibNoise.QualityMode.Medium;
			
			// 2: [Continent-with-ranges module]: Next, a curve module modifies the
			//    output value from the continent module so that very high values appear
			//    near sea level.  This defines the positions of the mountain ranges.
			Curve baseContinentCurve = new Curve(baseContinent_pe0);
			baseContinentCurve.Add(-2.0000 + sea_level,-1.625 + sea_level);
			baseContinentCurve.Add(-1.0000 + sea_level,-1.375 + sea_level);
			baseContinentCurve.Add( 0.0000 + sea_level,-0.375 + sea_level);
			baseContinentCurve.Add( 0.0625 + sea_level, 0.125 + sea_level);
			baseContinentCurve.Add( 0.1250 + sea_level, 0.250 + sea_level);
			baseContinentCurve.Add( 0.2500 + sea_level, 1.000 + sea_level);
			baseContinentCurve.Add( 0.5000 + sea_level, 0.250 + sea_level);
			baseContinentCurve.Add( 0.7500 + sea_level, 0.250 + sea_level);
			baseContinentCurve.Add( 1.0000 + sea_level, 0.500 + sea_level);
			baseContinentCurve.Add( 2.0000 + sea_level, 0.500 + sea_level);
			
			// 3: [Carver module]: This higher-frequency Perlin-noise module will be
			//    used by subsequent noise modules to carve out chunks from the mountain
			//    ranges within the continent-with-ranges module so that the mountain
			//    ranges will not be complely impassible.
			Perlin baseContinent_pe1 = new Perlin();
			baseContinent_pe1.Seed = seed + 1;
			baseContinent_pe1.Frequency = continent_frequency * 4.34275;
			baseContinent_pe1.Persistence = 0.5;
			baseContinent_pe1.Lacunarity = continent_lacunarity;
			baseContinent_pe1.OctaveCount = 11;
			baseContinent_pe1.Quality = LibNoise.QualityMode.Medium;
			
			// 4: [Scaled-carver module]: This scale/bias module scales the output
			//    value from the carver module such that it is usually near 1.0.  This
			//    is required for step 5.
			ScaleBias baseContinentScaleBias = new ScaleBias(baseContinent_pe1);
			baseContinentScaleBias.Scale = 0.375;
			baseContinentScaleBias.Bias = 0.625;
			
			// 5: [Carved-continent module]: This minimum-value module carves out chunks
			//    from the continent-with-ranges module.  It does this by ensuring that
			//    only the minimum of the output values from the scaled-carver module
			//    and the continent-with-ranges module contributes to the output value
			//    of this subgroup.  Most of the time, the minimum-value module will
			//    select the output value from the continents-with-ranges module since
			//    the output value from the scaled-carver module is usually near 1.0.
			//    Occasionally, the output value from the scaled-carver module will be
			//    less than the output value from the continent-with-ranges module, so
			//    in this case, the output value from the scaled-carver module is
			//    selected.
			Min baseContinentMin = new Min(baseContinentScaleBias, baseContinentCurve);
			
			// 6: [Clamped-continent module]: Finally, a clamp module modifies the
			//    carved-continent module to ensure that the output value of this
			//    subgroup is between -1.0 and 1.0.
			Clamp baseContinentDef = new Clamp(-1.0, 1.0, baseContinentMin);
			
			#endregion
			
			#region Continent Definition
			
			// 1: [Coarse-turbulence module]: This turbulence module warps the output
			//    value from the base-continent-definition subgroup, adding some coarse
			//    detail to it.
			Turbulence continentDef_tu0 = new Turbulence(baseContinentDef);
			continentDef_tu0.Seed = seed + 10;
			continentDef_tu0.Frequency = continent_frequency*15.25;
			continentDef_tu0.Power = continent_frequency/113.75;
			continentDef_tu0.Roughness = 13;
			
			// 2: [Intermediate-turbulence module]: This turbulence module warps the
			//    output value from the coarse-turbulence module.  This turbulence has
			//    a higher frequency, but lower power, than the coarse-turbulence
			//    module, adding some intermediate detail to it.
			Turbulence continentDef_tu1 = new Turbulence(continentDef_tu0);
			continentDef_tu1.Seed = seed + 11;
			continentDef_tu1.Frequency = continent_frequency*47.25;
			continentDef_tu1.Power = continent_frequency/433.75;
			continentDef_tu1.Roughness = 12;
			
			// 3: [Warped-base-continent-definition module]: This turbulence module
			//    warps the output value from the intermediate-turbulence module.  This
			//    turbulence has a higher frequency, but lower power, than the
			//    intermediate-turbulence module, adding some fine detail to it.
			Turbulence continentDef_tu2 = new Turbulence(continentDef_tu1);
			continentDef_tu2.Seed = seed + 12;
			continentDef_tu2.Frequency = continent_frequency * 5.25;//95.25
			continentDef_tu2.Power = continent_frequency * 1019.75;//1019.75
			continentDef_tu2.Roughness = 11;
			
			// 4: [Select-turbulence module]: At this stage, the turbulence is applied
			//    to the entire base-continent-definition subgroup, producing some very
			//    rugged, unrealistic coastlines.  This selector module selects the
			//    output values from the (unwarped) base-continent-definition subgroup
			//    and the warped-base-continent-definition module, based on the output
			//    value from the (unwarped) base-continent-definition subgroup.  The
			//    selection boundary is near sea level and has a relatively smooth
			//    transition.  In effect, only the higher areas of the base-continent-
			//    definition subgroup become warped; the underwater and coastal areas
			//    remain unaffected.
			Select continentDef = new Select(baseContinentDef, continentDef_tu1, baseContinentDef);
			continentDef.SetBounds(sea_level - 0.0375, sea_level + 1000.0375);
			continentDef.FallOff = 0.0625;
			
			#endregion
			
			
			#region Terrain Type
			// Module subgroup: terrain type definition (3 noise modules)
			//
			// This subgroup defines the positions of the terrain types on the planet.
			//
			// Terrain types include, in order of increasing roughness, plains, hills,
			// and mountains.
			//
			// This subgroup's output value is based on the output value from the
			// continent-definition group.  Rougher terrain mainly appears at higher
			// elevations.
			//
			// -1.0 represents the smoothest terrain types (plains and underwater) and
			// +1.0 represents the roughest terrain types (mountains).
			
			// 1: [Warped-continent module]: This turbulence module slightly warps the
			//    output value from the continent-definition group.  This prevents the
			//    rougher terrain from appearing exclusively at higher elevations.
			//    Rough areas may now appear in the the ocean, creating rocky islands
			//    and fjords.
			Turbulence terrainTypeDef_tu = new Turbulence(continentDef);
			terrainTypeDef_tu.Seed = seed + 20;
			terrainTypeDef_tu.Frequency = continent_frequency * 18.125;
			terrainTypeDef_tu.Power = continent_frequency / 20.59375 * TERRAIN_OFFSET;
			terrainTypeDef_tu.Roughness = 3;
			
			// 2: [Roughness-probability-shift module]: This terracing module sharpens
			//    the edges of the warped-continent module near sea level and lowers
			//    the slope towards the higher-elevation areas.  This shrinks the areas
			//    in which the rough terrain appears, increasing the "rarity" of rough
			//    terrain.
			Terrace terrainTypeDef = new Terrace(terrainTypeDef_tu);
			terrainTypeDef.ControlPoints.Add(-1.0);
			terrainTypeDef.ControlPoints.Add(shelf_level + sea_level/2.0);
			terrainTypeDef.ControlPoints.Add(1.0);
			
			#endregion
			
			#region Mountainous Terrain
			
			// Module subgroup: mountain base definition (9 noise modules)
			//
			// This subgroup generates the base-mountain elevations.  Other subgroups
			// will add the ridges and low areas to the base elevations.
			//
			// -1.0 represents low mountainous terrain and +1.0 represents high
			// mountainous terrain.
			
			// 1: [Mountain-ridge module]: This ridged-multifractal-noise module
			//    generates the mountain ridges.
			RidgedMultifractal mountainsBaseDef_rm0 = new RidgedMultifractal();
			mountainsBaseDef_rm0.Seed = seed + 30;
			mountainsBaseDef_rm0.Frequency = 17.0;//1723.0
			mountainsBaseDef_rm0.Lacunarity = mountain_lacunarity;
			mountainsBaseDef_rm0.OctaveCount = 4;
			mountainsBaseDef_rm0.Quality = LibNoise.QualityMode.Medium;
			
			// 2: [Scaled-mountain-ridge module]: Next, a scale/bias module scales the
			//    output value from the mountain-ridge module so that its ridges are not
			//    too high.  The reason for this is that another subgroup adds actual
			//    mountainous terrain to these ridges.
			ScaleBias mountainBaseDef_sb0 = new ScaleBias(mountainsBaseDef_rm0);
			mountainBaseDef_sb0.Scale = 0.5;
			mountainBaseDef_sb0.Bias = 0.375;
			
			// 3: [River-valley module]: This ridged-multifractal-noise module generates
			//    the river valleys.  It has a much lower frequency than the mountain-
			//    ridge module so that more mountain ridges will appear outside of the
			//    valleys.  Note that this noise module generates ridged-multifractal
			//    noise using only one octave; this information will be important in the
			//    next step.
			RidgedMultifractal mountainBaseDef_rm1 = new RidgedMultifractal();
			mountainBaseDef_rm1.Seed = seed + 31;
			mountainBaseDef_rm1.Frequency = 7.0;//367.0
			mountainBaseDef_rm1.Lacunarity = mountain_lacunarity;
			mountainBaseDef_rm1.OctaveCount = 1;
			mountainBaseDef_rm1.Quality = LibNoise.QualityMode.Medium;
			
			// 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
			//    scaling factor of -2.0 to the output value from the river-valley
			//    module.  This stretches the possible elevation values because one-
			//    octave ridged-multifractal noise has a lower range of output values
			//    than multiple-octave ridged-multifractal noise.  The negative scaling
			//    factor inverts the range of the output value, turning the ridges from
			//    the river-valley module into valleys.
			ScaleBias mountainBaseDef_sb1 = new ScaleBias(mountainBaseDef_rm1);
			mountainBaseDef_sb1.Scale = -2.0;
			mountainBaseDef_sb1.Bias = -0.5;
			
			// 5: [Low-flat module]: This low constant value is used by step 6.
			Const mountainBaseDef_co = new Const();
			mountainBaseDef_co.Value = -1.0;
			
			// 6: [Mountains-and-valleys module]: This blender module merges the
			//    scaled-mountain-ridge module and the scaled-river-valley module
			//    together.  It causes the low-lying areas of the terrain to become
			//    smooth, and causes the high-lying areas of the terrain to contain
			//    ridges.  To do this, it uses the scaled-river-valley module as the
			//    control module, causing the low-flat module to appear in the lower
			//    areas and causing the scaled-mountain-ridge module to appear in the
			//    higher areas.
			Blend mountainBaseDef_bl = new Blend(mountainBaseDef_co, mountainBaseDef_sb0, mountainBaseDef_sb1);
			
			// 7: [Coarse-turbulence module]: This turbulence module warps the output
			//    value from the mountain-and-valleys module, adding some coarse detail
			//    to it.
			Turbulence mountainBaseDef_tu0 = new Turbulence(mountainBaseDef_bl);
			mountainBaseDef_tu0.Seed = seed + 32;
			mountainBaseDef_tu0.Frequency = 1337.0;
			mountainBaseDef_tu0.Power = (1.0/6730.0 * mountains_twist);
			mountainBaseDef_tu0.Roughness = 4;
			
			// 8: [Warped-mountains-and-valleys module]: This turbulence module warps
			//    the output value from the coarse-turbulence module.  This turbulence
			//    has a higher frequency, but lower power, than the coarse-turbulence
			//    module, adding some fine detail to it.
			Turbulence mountainBaseDef = new Turbulence(mountainBaseDef_tu0);
			mountainBaseDef.Seed = seed + 33;
			mountainBaseDef.Frequency = 21221.0;
			mountainBaseDef.Power = (1.0 / 120157.0 * mountains_twist);
			mountainBaseDef.Roughness = 6;
			
			#endregion
			
			#region High Mountainous Terrain
			// Module subgroup: high mountainous terrain (5 noise modules)
			//
			// This subgroup generates the mountainous terrain that appears at high
			// elevations within the mountain ridges.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			//
			
			// 1: [Mountain-basis-0 module]: This ridged-multifractal-noise module,
			//    along with the mountain-basis-1 module, generates the individual
			//    mountains.
			RidgedMultifractal mountainousHigh_rm0 = new RidgedMultifractal();
			mountainousHigh_rm0.Seed = seed + 40;
			mountainousHigh_rm0.Frequency = 21.0;//2371.0
			mountainousHigh_rm0.Lacunarity = mountain_lacunarity;
			mountainousHigh_rm0.OctaveCount = 3;
			mountainousHigh_rm0.Quality = LibNoise.QualityMode.High;
			
			// 2: [Mountain-basis-1 module]: This ridged-multifractal-noise module,
			//    along with the mountain-basis-0 module, generates the individual
			//    mountains.
			RidgedMultifractal mountainousHigh_rm1 = new RidgedMultifractal();
			mountainousHigh_rm1.Seed = seed + 41;
			mountainousHigh_rm1.Frequency = 21.0;//2341.0
			mountainousHigh_rm1.Lacunarity = mountain_lacunarity;
			mountainousHigh_rm1.OctaveCount = 3;
			mountainousHigh_rm1.Quality = LibNoise.QualityMode.High;
			
			// 3: [High-mountains module]: Next, a maximum-value module causes more
			//    mountains to appear at the expense of valleys.  It does this by
			//    ensuring that only the maximum of the output values from the two
			//    ridged-multifractal-noise modules contribute to the output value of
			//    this subgroup.
			Max mountainousHigh_ma = new Max(mountainousHigh_rm0, mountainousHigh_rm1);
			
			// 4: [Warped-high-mountains module]: This turbulence module warps the
			//    output value from the high-mountains module, adding some detail to it.
			Turbulence mountainousHigh = new Turbulence(mountainousHigh_ma);
			mountainousHigh.Seed = seed + 42;
			mountainousHigh.Frequency = 31511.0;
			mountainousHigh.Power = (1.0/180371.0 * mountains_twist);
			mountainousHigh.Roughness = 4;
			
			#endregion
			
			#region low mountainous terrain
			
			// Module subgroup: low mountainous terrain (4 noise modules)
			//
			// This subgroup generates the mountainous terrain that appears at low
			// elevations within the river valleys.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			// 1: [Lowland-basis-0 module]: This ridged-multifractal-noise module,
			//    along with the lowland-basis-1 module, produces the low mountainous
			//    terrain.
			RidgedMultifractal mountainousLow_rm0 = new RidgedMultifractal();
			mountainousLow_rm0.Seed = seed + 50;
			mountainousLow_rm0.Frequency = 11.0;//1381.0
			mountainousLow_rm0.Lacunarity = mountain_lacunarity;
			mountainousLow_rm0.OctaveCount = 8;
			mountainousLow_rm0.Quality = LibNoise.QualityMode.High;
			
			// 2: [Lowland-basis-1 module]: This ridged-multifractal-noise module,
			//    along with the lowland-basis-0 module, produces the low mountainous
			//    terrain.
			RidgedMultifractal mountainousLow_rm1 = new RidgedMultifractal();
			mountainousLow_rm1.Seed = seed + 51;
			mountainousLow_rm1.Frequency = 17.0;//1427.0
			mountainousLow_rm1.Lacunarity = mountain_lacunarity;
			mountainousLow_rm1.OctaveCount = 8;
			mountainousLow_rm1.Quality = LibNoise.QualityMode.High;
			
			// 3: [Low-mountainous-terrain module]: This multiplication module combines
			//    the output values from the two ridged-multifractal-noise modules.
			//    This causes the following to appear in the resulting terrain:
			//    - Cracks appear when two negative output values are multiplied
			//      together.
			//    - Flat areas appear when a positive and a negative output value are
			//      multiplied together.
			//    - Ridges appear when two positive output values are multiplied
			//      together.
			Multiply mountainousLow = new Multiply(mountainousLow_rm0, mountainousLow_rm1);
			
			#endregion
			
			#region Mountainous Terrain
			
			// Module subgroup: mountainous terrain (7 noise modules)
			//
			// This subgroup generates the final mountainous terrain by combining the
			// high-mountainous-terrain subgroup with the low-mountainous-terrain
			// subgroup.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			// 1: [Scaled-low-mountainous-terrain module]: First, this scale/bias module
			//    scales the output value from the low-mountainous-terrain subgroup to a
			//    very low value and biases it towards -1.0.  This results in the low
			//    mountainous areas becoming more-or-less flat with little variation.
			//    This will also result in the low mountainous areas appearing at the
			//    lowest elevations in this subgroup.
			ScaleBias mountainousTerrain_sb0 = new ScaleBias(mountainousLow);
			mountainousTerrain_sb0.Scale = 0.03125;
			mountainousTerrain_sb0.Bias = -0.96875;
			
			// 2: [Scaled-high-mountainous-terrain module]: Next, this scale/bias module
			//    scales the output value from the high-mountainous-terrain subgroup to
			//    1/4 of its initial value and biases it so that its output value is
			//    usually positive.
			ScaleBias mountainousTerrain_sb1 = new ScaleBias(mountainousHigh);
			mountainousTerrain_sb1.Scale = 0.25;
			mountainousTerrain_sb1.Bias = 0.25;
			
			// 3: [Added-high-mountainous-terrain module]: This addition module adds the
			//    output value from the scaled-high-mountainous-terrain module to the
			//    output value from the mountain-base-definition subgroup.  Mountains
			//    now appear all over the terrain.
			Add mountainousTerrain_ad = new Add(mountainousTerrain_sb0, mountainousTerrain_sb1);
			
			// 4: [Combined-mountainous-terrain module]: Note that at this point, the
			//    entire terrain is covered in high mountainous terrain, even at the low
			//    elevations.  To make sure the mountains only appear at the higher
			//    elevations, this selector module causes low mountainous terrain to
			//    appear at the low elevations (within the valleys) and the high
			//    mountainous terrain to appear at the high elevations (within the
			//    ridges.)  To do this, this noise module selects the output value from
			//    the added-high-mountainous-terrain module if the output value from the
			//    mountain-base-definition subgroup is higher than a set amount.
			//    Otherwise, this noise module selects the output value from the scaled-
			//    low-mountainous-terrain module.
			Select mountainousTerrain_se = new Select(mountainousTerrain_sb0, mountainousTerrain_ad, mountainBaseDef);
			mountainousTerrain_se.SetBounds(-0.5, 999.5);
			mountainousTerrain_se.FallOff = 0.5;
			
			// 5: [Scaled-mountainous-terrain-module]: This scale/bias module slightly
			//    reduces the range of the output value from the combined-mountainous-
			//    terrain module, decreasing the heights of the mountain peaks.
			ScaleBias mountainousTerrain_sb2 = new ScaleBias(mountainousTerrain_se);
			mountainousTerrain_sb2.Scale = 0.8;
			mountainousTerrain_sb2.Bias = 0.0;
			
			// 6: [Glaciated-mountainous-terrain-module]: This exponential-curve module
			//    applies an exponential curve to the output value from the scaled-
			//    mountainous-terrain module.  This causes the slope of the mountains to
			//    smoothly increase towards higher elevations, as if a glacier grinded
			//    out those mountains.  This exponential-curve module expects the output
			//    value to range from -1.0 to +1.0.
			Exponent mountainousTerrain = new Exponent(mountainousTerrain_sb2);
			mountainousTerrain.Value = mountain_glaciation;
			
			#endregion
			
			#region Hilly Terrain
			
			// Module group: hilly terrain
			
			// Module subgroup: hilly terrain (11 noise modules)
			//
			// This subgroup generates the hilly terrain.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			//
			
			// 1: [Hills module]: This billow-noise module generates the hills.
			Billow hillyTerrain_bi = new Billow();
			hillyTerrain_bi.Seed = seed + 60;
			hillyTerrain_bi.Frequency = 13.0;//16630.0
			hillyTerrain_bi.Persistence = 0.5;
			hillyTerrain_bi.Lacunarity = hills_lacunarity;
			hillyTerrain_bi.OctaveCount = 6;
			hillyTerrain_bi.Quality = LibNoise.QualityMode.High;
			
			// 2: [Scaled-hills module]: Next, a scale/bias module scales the output
			//    value from the hills module so that its hilltops are not too high.
			//    The reason for this is that these hills are eventually added to the
			//    river valleys (see below.)
			ScaleBias hillyTerrain_sb0 = new ScaleBias(hillyTerrain_bi);
			hillyTerrain_sb0.Scale = 0.5;
			hillyTerrain_sb0.Bias = 0.5;
			
			// 3: [River-valley module]: This ridged-multifractal-noise module generates
			//    the river valleys.  It has a much lower frequency so that more hills
			//    will appear in between the valleys.  Note that this noise module
			//    generates ridged-multifractal noise using only one octave; this
			//    information will be important in the next step.
			RidgedMultifractal hillyTerrain_rm = new RidgedMultifractal();
			hillyTerrain_rm.Seed = seed + 61;
			hillyTerrain_rm.Frequency = 36.5;//367.5
			hillyTerrain_rm.Lacunarity = hills_lacunarity;
			hillyTerrain_rm.Quality = LibNoise.QualityMode.High;
			hillyTerrain_rm.OctaveCount = 1;
			
			// 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
			//    scaling factor of -2.0 to the output value from the river-valley
			//    module.  This stretches the possible elevation values because one-
			//    octave ridged-multifractal noise has a lower range of output values
			//    than multiple-octave ridged-multifractal noise.  The negative scaling
			//    factor inverts the range of the output value, turning the ridges from
			//    the river-valley module into valleys.
			ScaleBias hillyTerrain_sb1 = new ScaleBias(hillyTerrain_rm);
			hillyTerrain_sb1.Scale = -2.0;
			hillyTerrain_sb1.Bias = -0.5;
			
			// 5: [Low-flat module]: This low constant value is used by step 6.
			Const hillyTerrain_co = new Const();
			hillyTerrain_co.Value = -1.0;
			
			// 6: [Mountains-and-valleys module]: This blender module merges the
			//    scaled-hills module and the scaled-river-valley module together.  It
			//    causes the low-lying areas of the terrain to become smooth, and causes
			//    the high-lying areas of the terrain to contain hills.  To do this, it
			//    uses the scaled-hills module as the control module, causing the low-
			//    flat module to appear in the lower areas and causing the scaled-river-
			//    valley module to appear in the higher areas.
			Blend hillyTerrain_bl = new Blend(hillyTerrain_co, hillyTerrain_sb1, hillyTerrain_sb0);
			
			// 7: [Scaled-hills-and-valleys module]: This scale/bias module slightly
			//    reduces the range of the output value from the hills-and-valleys
			//    module, decreasing the heights of the hilltops.
			ScaleBias hillyTerrain_sb2 = new ScaleBias(hillyTerrain_bl);
			hillyTerrain_sb2.Scale = 0.75;
			hillyTerrain_sb2.Bias = -0.25;
			
			// 8: [Increased-slope-hilly-terrain module]: To increase the hill slopes at
			//    higher elevations, this exponential-curve module applies an
			//    exponential curve to the output value the scaled-hills-and-valleys
			//    module.  This exponential-curve module expects the input value to
			//    range from -1.0 to 1.0.
			Exponent hillyTerrain_ex = new Exponent(hillyTerrain_sb2);
			hillyTerrain_ex.Value = 1.375;
			
			// 9: [Coarse-turbulence module]: This turbulence module warps the output
			//    value from the increased-slope-hilly-terrain module, adding some
			//    coarse detail to it.
			Turbulence hillyTerrain_tu0 = new Turbulence(hillyTerrain_ex);
			hillyTerrain_tu0.Seed = seed + 62;
			hillyTerrain_tu0.Frequency = 1531.0;
			hillyTerrain_tu0.Power = (1.0/16921.0 * hills_twist);
			hillyTerrain_tu0.Roughness = 4;
			
			// 10: [Warped-hilly-terrain module]: This turbulence module warps the
			//     output value from the coarse-turbulence module.  This turbulence has
			//     a higher frequency, but lower power, than the coarse-turbulence
			//     module, adding some fine detail to it.
			Turbulence hillyTerrain = new Turbulence(hillyTerrain_tu0);
			hillyTerrain.Seed = seed + 63;
			hillyTerrain.Frequency = 21617.0;
			hillyTerrain.Power = (1.0/117529.0 * hills_twist);
			hillyTerrain.Roughness = 6;
			
			#endregion
			
			#region Plains Terrain
			
			// Module group: plains terrain
			
			// Module subgroup: plains terrain (7 noise modules)
			//
			// This subgroup generates the plains terrain.
			//
			// Because this subgroup will eventually be flattened considerably, the
			// types and combinations of noise modules that generate the plains are not
			// really that important; they only need to "look" interesting.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			//
			
			// 1: [Plains-basis-0 module]: This billow-noise module, along with the
			//    plains-basis-1 module, produces the plains.
			Billow plainsTerrain_bi0 = new Billow();
			plainsTerrain_bi0.Seed = seed + 70;
			plainsTerrain_bi0.Frequency = 17.5;//1097.5
			plainsTerrain_bi0.Persistence = 0.5;
			plainsTerrain_bi0.Lacunarity = plains_lacunarity;
			plainsTerrain_bi0.OctaveCount = 8;
			plainsTerrain_bi0.Quality = LibNoise.QualityMode.High;
			
			// 2: [Positive-plains-basis-0 module]: This scale/bias module makes the
			//    output value from the plains-basis-0 module positive since this output
			//    value will be multiplied together with the positive-plains-basis-1
			//    module.
			ScaleBias plainsTerrain_sb0 = new ScaleBias(plainsTerrain_bi0);
			plainsTerrain_sb0.Scale = 0.5;
			plainsTerrain_sb0.Bias = 0.5;
			
			// 3: [Plains-basis-1 module]: This billow-noise module, along with the
			//    plains-basis-2 module, produces the plains.
			Billow plainsTerrain_bi1 = new Billow();
			plainsTerrain_bi1.Seed = 71;
			plainsTerrain_bi1.Frequency = 19.5;//1319.5
			plainsTerrain_bi1.Persistence = 0.5;
			plainsTerrain_bi1.Lacunarity = plains_lacunarity;
			plainsTerrain_bi1.OctaveCount = 8;
			plainsTerrain_bi1.Quality = LibNoise.QualityMode.High;
			
			// 4: [Positive-plains-basis-1 module]: This scale/bias module makes the
			//    output value from the plains-basis-1 module positive since this output
			//    value will be multiplied together with the positive-plains-basis-0
			//    module.
			ScaleBias plainsTerrain_sb1 = new ScaleBias(plainsTerrain_bi1);
			plainsTerrain_sb1.Scale = 0.5;
			plainsTerrain_sb1.Bias = 0.5;
			
			// 5: [Combined-plains-basis module]: This multiplication module combines
			//    the two plains basis modules together.
			Multiply plainsTerrain_mu = new Multiply(plainsTerrain_sb0, plainsTerrain_sb1);
			
			// 6: [Rescaled-plains-basis module]: This scale/bias module maps the output
			//    value that ranges from 0.0 to 1.0 back to a value that ranges from
			//    -1.0 to +1.0.
			ScaleBias plainsTerrain = new ScaleBias(plainsTerrain_mu);
			plainsTerrain.Scale = 2.0;
			plainsTerrain.Bias = -1.0;
			
			#endregion
			
			#region Badlands Terrain
			
			// Module group: badlands terrain
			
			// Module subgroup: badlands sand (6 noise modules)
			//
			// This subgroup generates the sandy terrain for the badlands.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			// 1: [Sand-dunes module]: This ridged-multifractal-noise module generates
			//    sand dunes.  This ridged-multifractal noise is generated with a single
			//    octave, which makes very smooth dunes.
			RidgedMultifractal badlandsSand_rm = new RidgedMultifractal();
			badlandsSand_rm.Seed = seed + 80;
			badlandsSand_rm.Frequency = 63.5;//6163.5
			badlandsSand_rm.Lacunarity = badlands_lacunarity;
			badlandsSand_rm.Quality = LibNoise.QualityMode.High;
			badlandsSand_rm.OctaveCount = 1;
			
			// 2: [Scaled-sand-dunes module]: This scale/bias module shrinks the dune
			//    heights by a small amount.  This is necessary so that the subsequent
			//    noise modules in this subgroup can add some detail to the dunes.
			ScaleBias badlandsSand_sb0 = new ScaleBias(badlandsSand_rm);
			badlandsSand_sb0.Scale = 0.875;
			badlandsSand_sb0.Bias = 0.0;
			
			// 3: [Dune-detail module]: This noise module uses Voronoi polygons to
			//    generate the detail to add to the dunes.  By enabling the distance
			//    algorithm, small polygonal pits are generated; the edges of the pits
			//    are joined to the edges of nearby pits.
			Voronoi badlandsSand_vo = new Voronoi();
			badlandsSand_vo.Seed = seed + 81;
			badlandsSand_vo.Frequency = 163.25;//16183.25
			badlandsSand_vo.Displacement = 0.0;
			badlandsSand_vo.UseDistance = true;
			
			// 4: [Scaled-dune-detail module]: This scale/bias module shrinks the dune
			//    details by a large amount.  This is necessary so that the subsequent
			//    noise modules in this subgroup can add this detail to the sand-dunes
			//    module.
			ScaleBias badlandsSand_sb1 = new ScaleBias(badlandsSand_vo);
			badlandsSand_sb1.Scale = 0.25;
			badlandsSand_sb1.Bias = 0.25;
			
			// 5: [Dunes-with-detail module]: This addition module combines the scaled-
			//    sand-dunes module with the scaled-dune-detail module.
			Add badlandsSand = new Add(badlandsSand_sb0, badlandsSand_sb1);
			
			#endregion
			
			#region Badlands Cliffs
			
			// Module subgroup: badlands cliffs (7 noise modules)
			//
			// This subgroup generates the cliffs for the badlands.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			// 1: [Cliff-basis module]: This Perlin-noise module generates some coherent
			//    noise that will be used to generate the cliffs.
			Perlin badlandsCliffs_pe = new Perlin();
			badlandsCliffs_pe.Seed = seed + 90;
			badlandsCliffs_pe.Frequency = continent_frequency * 29.0;//839.0
			badlandsCliffs_pe.Persistence = 0.5;
			badlandsCliffs_pe.Lacunarity = badlands_lacunarity;
			badlandsCliffs_pe.OctaveCount = 6;
			badlandsCliffs_pe.Quality = LibNoise.QualityMode.Medium;
			
			// 2: [Cliff-shaping module]: Next, this curve module applies a curve to the
			//    output value from the cliff-basis module.  This curve is initially
			//    very shallow, but then its slope increases sharply.  At the highest
			//    elevations, the curve becomes very flat again.  This produces the
			//    stereotypical Utah-style desert cliffs.
			Curve badlandsCliffs_cu = new Curve(badlandsCliffs_pe);
			badlandsCliffs_cu.Add (-2.0000, -2.0000);
			badlandsCliffs_cu.Add (-1.0000, -1.2500);
			badlandsCliffs_cu.Add (-0.0000, -0.7500);
			badlandsCliffs_cu.Add ( 0.5000, -0.2500);
			badlandsCliffs_cu.Add ( 0.6250,  0.8750);
			badlandsCliffs_cu.Add ( 0.7500,  1.0000);
			badlandsCliffs_cu.Add ( 2.0000,  1.2500);
			
			// 3: [Clamped-cliffs module]: This clamping module makes the tops of the
			//    cliffs very flat by clamping the output value from the cliff-shaping
			//    module so that the tops of the cliffs are very flat.
			Clamp badlandsCliffs_cl = new Clamp(badlandsCliffs_cu);
			badlandsCliffs_cl.SetBounds(-999.125, 0.875);
			
			// 4: [Terraced-cliffs module]: Next, this terracing module applies some
			//    terraces to the clamped-cliffs module in the lower elevations before
			//    the sharp cliff transition.
			Terrace badlandsCliffs_te = new Terrace(badlandsCliffs_cl);
			badlandsCliffs_te.Add (-1.0000);
			badlandsCliffs_te.Add (-0.8750);
			badlandsCliffs_te.Add (-0.7500);
			badlandsCliffs_te.Add (-0.5000);
			badlandsCliffs_te.Add ( 0.0000);
			badlandsCliffs_te.Add ( 1.0000);
			
			// 5: [Coarse-turbulence module]: This turbulence module warps the output
			//    value from the terraced-cliffs module, adding some coarse detail to
			//    it.
			Turbulence badlandsCliffs_tu0 = new Turbulence(badlandsCliffs_te);
			badlandsCliffs_tu0.Seed = seed + 91;
			badlandsCliffs_tu0.Frequency = 16111.0;
			badlandsCliffs_tu0.Power = (1.0/141539.0 * badlands_twist);
			badlandsCliffs_tu0.Roughness = 3;
			
			// 6: [Warped-cliffs module]: This turbulence module warps the output value
			//    from the coarse-turbulence module.  This turbulence has a higher
			//    frequency, but lower power, than the coarse-turbulence module, adding
			//    some fine detail to it.
			Turbulence badlandsCliffs = new Turbulence(badlandsCliffs_tu0);
			badlandsCliffs.Seed = seed + 92;
			badlandsCliffs.Frequency = 36107.0;
			badlandsCliffs.Power = (1.0/211543.0 * badlands_twist);
			badlandsCliffs.Roughness = 3;
			
			#endregion
			
			#region Badlands Terrain Final
			
			// Module subgroup: badlands terrain (3 noise modules)
			//
			// Generates the final badlands terrain.
			//
			// Using a scale/bias module, the badlands sand is flattened considerably,
			// then the sand elevations are lowered to around -1.0.  The maximum value
			// from the flattened sand module and the cliff module contributes to the
			// final elevation.  This causes sand to appear at the low elevations since
			// the sand is slightly higher than the cliff base.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			// 1: [Scaled-sand-dunes module]: This scale/bias module considerably
			//    flattens the output value from the badlands-sands subgroup and lowers
			//    this value to near -1.0.
			ScaleBias badlandsTerrain_sb = new ScaleBias(badlandsSand);
			badlandsTerrain_sb.Scale = 0.25;
			badlandsTerrain_sb.Bias = -0.75;
			
			// 2: [Dunes-and-cliffs module]: This maximum-value module causes the dunes
			//    to appear in the low areas and the cliffs to appear in the high areas.
			//    It does this by selecting the maximum of the output values from the
			//    scaled-sand-dunes module and the badlands-cliffs subgroup.
			Max badlandsTerrain = new Max(badlandsCliffs, badlandsTerrain_sb);
			
			#endregion
			
			#region River Positions
			
			// Module group: river positions
			
			// Module subgroup: river positions (7 noise modules)
			//
			// This subgroup generates the river positions.
			//
			// -1.0 represents the lowest elevations and +1.0 represents the highest
			// elevations.
			
			// 1: [Large-river-basis module]: This ridged-multifractal-noise module
			//    creates the large, deep rivers.
			RidgedMultifractal riverPositions_rm0 = new RidgedMultifractal();
			riverPositions_rm0.Seed = seed + 100;
			riverPositions_rm0.Frequency = 18.75;
			riverPositions_rm0.Lacunarity = continent_lacunarity;
			riverPositions_rm0.OctaveCount = 1;
			riverPositions_rm0.Quality = LibNoise.QualityMode.High;
			
			// 2: [Large-river-curve module]: This curve module applies a curve to the
			//    output value from the large-river-basis module so that the ridges
			//    become inverted.  This creates the rivers.  This curve also compresses
			//    the edge of the rivers, producing a sharp transition from the land to
			//    the river bottom.
			Curve riverPositions_cu0 = new Curve(riverPositions_rm0);
			riverPositions_cu0.Add (-2.000,  2.000);
			riverPositions_cu0.Add (-1.000,  1.000);
			riverPositions_cu0.Add (-0.125,  0.875);
			riverPositions_cu0.Add ( 0.000, -1.000);
			riverPositions_cu0.Add ( 1.000, -1.500);
			riverPositions_cu0.Add ( 2.000, -2.000);
			
			/// 3: [Small-river-basis module]: This ridged-multifractal-noise module
			//     creates the small, shallow rivers.
			RidgedMultifractal riverPositions_rm1 = new RidgedMultifractal();
			riverPositions_rm1.Seed = seed + 101;
			riverPositions_rm1.Frequency = 43.25;
			riverPositions_rm1.Lacunarity = continent_lacunarity;
			riverPositions_rm1.OctaveCount = 1;
			riverPositions_rm1.Quality = LibNoise.QualityMode.High;
			
			// 4: [Small-river-curve module]: This curve module applies a curve to the
			//    output value from the small-river-basis module so that the ridges
			//    become inverted.  This creates the rivers.  This curve also compresses
			//    the edge of the rivers, producing a sharp transition from the land to
			//    the river bottom.
			Curve riverPositions_cu1 = new Curve(riverPositions_rm1);
			riverPositions_cu1.Add (-2.000,  2.0000);
			riverPositions_cu1.Add (-1.000,  1.5000);
			riverPositions_cu1.Add (-0.125,  1.4375);
			riverPositions_cu1.Add ( 0.000,  0.5000);
			riverPositions_cu1.Add ( 1.000,  0.2500);
			riverPositions_cu1.Add ( 2.000,  0.0000);
			
			// 5: [Combined-rivers module]: This minimum-value module causes the small
			//    rivers to cut into the large rivers.  It does this by selecting the
			//    minimum output values from the large-river-curve module and the small-
			//    river-curve module.
			Min riverPositions_mi = new Min(riverPositions_cu0, riverPositions_cu1);
			
			// 6: [Warped-rivers module]: This turbulence module warps the output value
			//    from the combined-rivers module, which twists the rivers.  The high
			//    roughness produces less-smooth rivers.
			Turbulence riverPositions = new Turbulence(riverPositions_mi);
			riverPositions.Seed = seed + 102;
			riverPositions.Frequency = 9.25;
			riverPositions.Power = (1.0/57.75);
			riverPositions.Roughness = 6;
			
			#endregion
			
			#region Scaled Mountainous Terrain
			
			// Module group: scaled mountainous terrain
			
			// Module subgroup: scaled mountainous terrain (6 noise modules)
			//
			// This subgroup scales the output value from the mountainous-terrain group
			// so that it can be added to the elevation defined by the continent-
			// definition group.
			//
			// This subgroup scales the output value such that it is almost always
			// positive.  This is done so that a negative elevation does not get applied
			// to the continent-definition group, preventing parts of that group from
			// having negative terrain features "stamped" into it.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Base-scaled-mountainous-terrain module]: This scale/bias module
			//    scales the output value from the mountainous-terrain group so that the
			//    output value is measured in planetary elevation units.
			ScaleBias scaledMountainousTerrain_sb0 = new ScaleBias(mountainousTerrain);
			scaledMountainousTerrain_sb0.Scale = 0.125;
			scaledMountainousTerrain_sb0.Bias = 0.125;
			
			// 2: [Base-peak-modulation module]: At this stage, most mountain peaks have
			//    roughly the same elevation.  This Perlin-noise module generates some
			//    random values that will be used by subsequent noise modules to
			//    randomly change the elevations of the mountain peaks.
			Perlin scaledMountainousTerrain_pe = new Perlin();
			scaledMountainousTerrain_pe.Seed = seed + 110;
			scaledMountainousTerrain_pe.Frequency = 14.5;
			scaledMountainousTerrain_pe.Persistence = 0.5;
			scaledMountainousTerrain_pe.Lacunarity = mountain_lacunarity;
			scaledMountainousTerrain_pe.OctaveCount = 6;
			scaledMountainousTerrain_pe.Quality = LibNoise.QualityMode.Medium;
			
			// 3: [Peak-modulation module]: This exponential-curve module applies an
			//    exponential curve to the output value from the base-peak-modulation
			//    module.  This produces a small number of high values and a much larger
			//    number of low values.  This means there will be a few peaks with much
			//    higher elevations than the majority of the peaks, making the terrain
			//    features more varied.
			Exponent scaledMountainousTerrain_ex = new Exponent(scaledMountainousTerrain_pe);
			scaledMountainousTerrain_ex.Value = 1.25;
			
			// 4: [Scaled-peak-modulation module]: This scale/bias module modifies the
			//    range of the output value from the peak-modulation module so that it
			//    can be used as the modulator for the peak-height-multiplier module.
			//    It is important that this output value is not much lower than 1.0.
			ScaleBias scaledMountainousterrain_sb1 = new ScaleBias(scaledMountainousTerrain_ex);
			scaledMountainousterrain_sb1.Scale = 0.25;
			scaledMountainousterrain_sb1.Bias = 1.0;
			
			// 5: [Peak-height-multiplier module]: This multiplier module modulates the
			//    heights of the mountain peaks from the base-scaled-mountainous-terrain
			//    module using the output value from the scaled-peak-modulation module.
			Multiply scaledMountainousTerrain = new Multiply(scaledMountainousTerrain_sb0, scaledMountainousterrain_sb1);
			
			#endregion
			
			#region Scaled Hilly Terrain
			
			// Module group: scaled hilly terrain
			
			// Module subgroup: scaled hilly terrain (6 noise modules)
			//
			// This subgroup scales the output value from the hilly-terrain group so
			// that it can be added to the elevation defined by the continent-
			// definition group.  The scaling amount applied to the hills is one half of
			// the scaling amount applied to the scaled-mountainous-terrain group.
			//
			// This subgroup scales the output value such that it is almost always
			// positive.  This is done so that negative elevations are not applied to
			// the continent-definition group, preventing parts of the continent-
			// definition group from having negative terrain features "stamped" into it.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			//
			
			// 1: [Base-scaled-hilly-terrain module]: This scale/bias module scales the
			//    output value from the hilly-terrain group so that this output value is
			//    measured in planetary elevation units 
			ScaleBias scaledHillyTerrain_sb0 = new ScaleBias(hillyTerrain);
			scaledHillyTerrain_sb0.Scale = 0.0625;
			scaledHillyTerrain_sb0.Bias = 0.0625;
			
			// 2: [Base-hilltop-modulation module]: At this stage, most hilltops have
			//    roughly the same elevation.  This Perlin-noise module generates some
			//    random values that will be used by subsequent noise modules to
			//    randomly change the elevations of the hilltops.
			Perlin scaledHillyTerrain_pe = new Perlin();
			scaledHillyTerrain_pe.Seed = seed + 120;
			scaledHillyTerrain_pe.Frequency = 13.5;
			scaledHillyTerrain_pe.Persistence = 0.5;
			scaledHillyTerrain_pe.Lacunarity = hills_lacunarity;
			scaledHillyTerrain_pe.OctaveCount = 6;
			scaledHillyTerrain_pe.Quality = LibNoise.QualityMode.Medium;
			
			// 3: [Hilltop-modulation module]: This exponential-curve module applies an
			//    exponential curve to the output value from the base-hilltop-modulation
			//    module.  This produces a small number of high values and a much larger
			//    number of low values.  This means there will be a few hilltops with
			//    much higher elevations than the majority of the hilltops, making the
			//    terrain features more varied.
			Exponent scaledHillyTerrain_ex = new Exponent(scaledHillyTerrain_pe);
			scaledHillyTerrain_ex.Value = 1.25;
			
			// 4: [Scaled-hilltop-modulation module]: This scale/bias module modifies
			//    the range of the output value from the hilltop-modulation module so
			//    that it can be used as the modulator for the hilltop-height-multiplier
			//    module.  It is important that this output value is not much lower than
			//    1.0.
			ScaleBias scaledHillyTerrain_sb1 = new ScaleBias(scaledHillyTerrain_ex);
			scaledHillyTerrain_sb1.Scale = 0.5;
			scaledHillyTerrain_sb1.Bias = 1.5;
			
			// 5: [Hilltop-height-multiplier module]: This multiplier module modulates
			//    the heights of the hilltops from the base-scaled-hilly-terrain module
			//    using the output value from the scaled-hilltop-modulation module.
			Multiply scaledHillyTerrain = new Multiply(scaledHillyTerrain_sb0, scaledHillyTerrain_sb1);
			
			#endregion
			
			#region Scaled Plains Terrain
			
			// Module group: scaled plains terrain
			
			// Module subgroup: scaled plains terrain (2 noise modules)
			//
			// This subgroup scales the output value from the plains-terrain group so
			// that it can be added to the elevations defined by the continent-
			// definition group.
			//
			// This subgroup scales the output value such that it is almost always
			// positive.  This is done so that negative elevations are not applied to
			// the continent-definition group, preventing parts of the continent-
			// definition group from having negative terrain features "stamped" into it.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Scaled-plains-terrain module]: This scale/bias module greatly
			//    flattens the output value from the plains terrain.  This output value
			//    is measured in planetary elevation units 
			ScaleBias scaledPlainsTerrain = new ScaleBias(plainsTerrain);
			scaledPlainsTerrain.Scale = 0.00390625;
			scaledPlainsTerrain.Bias = 0.0078125;
			
			#endregion
			
			#region Scaled Badlands Terrain
			
			// Module group: scaled badlands terrain
			
			// Module subgroup: scaled badlands terrain (2 noise modules)
			//
			// This subgroup scales the output value from the badlands-terrain group so
			// that it can be added to the elevations defined by the continent-
			// definition group.
			//
			// This subgroup scales the output value such that it is almost always
			// positive.  This is done so that negative elevations are not applied to
			// the continent-definition group, preventing parts of the continent-
			// definition group from having negative terrain features "stamped" into it.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Scaled-badlands-terrain module]: This scale/bias module scales the
			//    output value from the badlands-terrain group so that it is measured
			//    in planetary elevation units 
			ScaleBias scaledBadlandsTerrain = new ScaleBias(badlandsTerrain);
			scaledBadlandsTerrain.Scale = 0.0625;
			scaledBadlandsTerrain.Bias = 0.0625;
			
			#endregion
			
			#region Final Planet
			// Module group: final planet
			
			// Module subgroup: continental shelf (6 noise modules)
			//
			// This module subgroup creates the continental shelves.
			//
			// The output value from this module subgroup are measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Shelf-creator module]: This terracing module applies a terracing
			//    curve to the continent-definition group at the specified shelf level.
			//    This terrace becomes the continental shelf.  Note that this terracing
			//    module also places another terrace below the continental shelf near
			//    -1.0.  The bottom of this terrace is defined as the bottom of the
			//    ocean; subsequent noise modules will later add oceanic trenches to the
			//    bottom of the ocean.
			Terrace continentalShelf_te = new Terrace(continentDef);
			continentalShelf_te.Add(-1.0);
			continentalShelf_te.Add(-0.75);
			continentalShelf_te.Add(shelf_level);
			continentalShelf_te.Add(1.0);
			
			// 2: [Oceanic-trench-basis module]: This ridged-multifractal-noise module
			//    generates some coherent noise that will be used to generate the
			//    oceanic trenches.  The ridges represent the bottom of the trenches.
			RidgedMultifractal continentalShelf_rm = new RidgedMultifractal();
			continentalShelf_rm.Seed = seed + 130;
			continentalShelf_rm.Frequency = continent_frequency * 4.375;//4.375
			continentalShelf_rm.Lacunarity = continent_lacunarity;
			continentalShelf_rm.OctaveCount = 16;
			continentalShelf_rm.Quality = LibNoise.QualityMode.High;
			
			// 3: [Oceanic-trench module]: This scale/bias module inverts the ridges
			//    from the oceanic-trench-basis-module so that the ridges become
			//    trenches.  This noise module also reduces the depth of the trenches so
			//    that their depths are measured in planetary elevation units.
			ScaleBias continentalShelf_sb = new ScaleBias(continentalShelf_rm);
			continentalShelf_sb.Scale = -0.125;
			continentalShelf_sb.Bias = -0.125;
			
			// 4: [Clamped-sea-bottom module]: This clamping module clamps the output
			//    value from the shelf-creator module so that its possible range is
			//    from the bottom of the ocean to sea level.  This is done because this
			//    subgroup is only concerned about the oceans.
			Clamp continentalShelf_cl = new Clamp(continentalShelf_te);
			continentalShelf_cl.SetBounds(-0.75, sea_level);
			
			// 5: [Shelf-and-trenches module]: This addition module adds the oceanic
			//    trenches to the clamped-sea-bottom module.
			Add continentShelf = new Add(continentalShelf_sb, continentalShelf_cl);
			
			#endregion
			
			#region Base Continent Elevations
			
			// Module group: base continent elevations (3 noise modules)
			//
			// This subgroup generates the base elevations for the continents, before
			// terrain features are added.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Base-scaled-continent-elevations module]: This scale/bias module
			//    scales the output value from the continent-definition group so that it
			//    is measured in planetary elevation units 
			ScaleBias baseContinentElev_sb = new ScaleBias(continentDef);
			baseContinentElev_sb.Scale = cont_height_scale;
			baseContinentElev_sb.Bias = 0.0;
			
			// 2: [Base-continent-with-oceans module]: This selector module applies the
			//    elevations of the continental shelves to the base elevations of the
			//    continent.  It does this by selecting the output value from the
			//    continental-shelf subgroup if the corresponding output value from the
			//    continent-definition group is below the shelf level.  Otherwise, it
			//    selects the output value from the base-scaled-continent-elevations
			//    module.
			Select baseContinentElev = new Select(baseContinentElev_sb, continentShelf, continentDef);
			baseContinentElev.SetBounds(shelf_level - 1000.0, shelf_level);
			baseContinentElev.FallOff = 0.03125;
			
			#endregion
			
			#region Continents With Plains
			
			// Module subgroup: continents with plains (2 noise modules)
			//
			// This subgroup applies the scaled-plains-terrain group to the base-
			// continent-elevation subgroup.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Continents-with-plains module]:  This addition module adds the
			//    scaled-plains-terrain group to the base-continent-elevation subgroup.
			Add continentsWithPlains = new Add(baseContinentElev, scaledPlainsTerrain);
			
			#endregion
			
			#region Continents With Hills
			
			// Module subgroup: continents with hills (3 noise modules)
			//
			// This subgroup applies the scaled-hilly-terrain group to the continents-
			// with-plains subgroup.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Continents-with-hills module]:  This addition module adds the scaled-
			//    hilly-terrain group to the base-continent-elevation subgroup.
			Add continentsWithHills_ad = new Add(baseContinentElev, scaledHillyTerrain);
			
			// 2: [Select-high-elevations module]: This selector module ensures that
			//    the hills only appear at higher elevations.  It does this by selecting
			//    the output value from the continent-with-hills module if the
			//    corresponding output value from the terrain-type-defintion group is
			//    above a certain value. Otherwise, it selects the output value from the
			//    continents-with-plains subgroup.
			Select continentsWithHills = new Select(continentsWithPlains, continentsWithHills_ad, terrainTypeDef);
			continentsWithHills.SetBounds(1.0 - hills_amount, 1001.0 - hills_amount);
			continentsWithHills.FallOff = 0.25;
			
			#endregion
			
			#region Continents With Mountains
			
			// Module subgroup: continents with mountains (5 noise modules)
			//
			// This subgroup applies the scaled-mountainous-terrain group to the
			// continents-with-hills subgroup.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Continents-and-mountains module]:  This addition module adds the
			//    scaled-mountainous-terrain group to the base-continent-elevation
			//    subgroup.
			Add continentsWithMountains_ad0 = new Add(baseContinentElev, scaledMountainousTerrain);
			
			// 2: [Increase-mountain-heights module]:  This curve module applies a curve
			//    to the output value from the continent-definition group.  This
			//    modified output value is used by a subsequent noise module to add
			//    additional height to the mountains based on the current continent
			//    elevation.  The higher the continent elevation, the higher the
			//    mountains.
			Curve continentsWithMountains_cu = new Curve(continentDef);
			continentsWithMountains_cu.Add(                  -1.0, -0.0625);
			continentsWithMountains_cu.Add(                   0.0,  0.0000);
			continentsWithMountains_cu.Add(1.0 - mountains_amount,  0.0625);
			continentsWithMountains_cu.Add(                   1.0,  0.2500);
			
			// 3: [Add-increased-mountain-heights module]: This addition module adds
			//    the increased-mountain-heights module to the continents-and-
			//    mountains module.  The highest continent elevations now have the
			//    highest mountains.
			Add continentsWithMountains_ad1 = new Add(continentsWithMountains_ad0, continentsWithMountains_cu);
			
			// 4: [Select-high-elevations module]: This selector module ensures that
			//    mountains only appear at higher elevations.  It does this by selecting
			//    the output value from the continent-with-mountains module if the
			//    corresponding output value from the terrain-type-defintion group is
			//    above a certain value.  Otherwise, it selects the output value from
			//    the continents-with-hills subgroup.  Note that the continents-with-
			//    hills subgroup also contains the plains terrain.
			Select continentsWithMountains = new Select(continentsWithHills, continentsWithMountains_ad1, terrainTypeDef);
			continentsWithMountains.SetBounds (1.0 - mountains_amount,1001.0 - mountains_amount);
			continentsWithMountains.FallOff = 0.25;
			
			#endregion
			
			#region Continents With Badlands
			
			// Module subgroup: continents with badlands (5 noise modules)
			//
			// This subgroup applies the scaled-badlands-terrain group to the
			// continents-with-mountains subgroup.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Badlands-positions module]: This Perlin-noise module generates some
			//    random noise, which is used by subsequent noise modules to specify the
			//    locations of the badlands.
			Perlin continentsWithBadlands_pe = new Perlin();
			continentsWithBadlands_pe.Seed = seed + 140;
			continentsWithBadlands_pe.Frequency = 16.5;
			continentsWithBadlands_pe.Persistence = 0.5;
			continentsWithBadlands_pe.Lacunarity = continent_lacunarity;
			continentsWithBadlands_pe.OctaveCount = 2;
			continentsWithBadlands_pe.Quality = LibNoise.QualityMode.Medium;
			
			// 2: [Continents-and-badlands module]:  This addition module adds the
			//    scaled-badlands-terrain group to the base-continent-elevation
			//    subgroup
			Add continentsWithBadlands_ad = new Add(baseContinentElev, scaledBadlandsTerrain);
			
			// 3: [Select-badlands-positions module]: This selector module places
			//    badlands at random spots on the continents based on the Perlin noise
			//    generated by the badlands-positions module.  To do this, it selects
			//    the output value from the continents-and-badlands module if the
			//    corresponding output value from the badlands-position module is
			//    greater than a specified value.  Otherwise, this selector module
			//    selects the output value from the continents-with-mountains subgroup.
			//    There is also a wide transition between these two noise modules so
			//    that the badlands can blend into the rest of the terrain on the
			//    continents.
			Select continentsWithBadlands_se = new Select(continentsWithMountains, continentsWithBadlands_ad, continentsWithBadlands_pe);
			continentsWithBadlands_se.SetBounds(1.0 - badlands_amount, 1001.0 - badlands_amount);
			continentsWithBadlands_se.FallOff = 0.25;
			
			// 4: [Apply-badlands module]: This maximum-value module causes the badlands
			//    to "poke out" from the rest of the terrain.  It does this by ensuring
			//    that only the maximum of the output values from the continents-with-
			//    mountains subgroup and the select-badlands-positions modules
			//    contribute to the output value of this subgroup.  One side effect of
			//    this process is that the badlands will not appear in mountainous
			//    terrain.
			Max continentsWithBadlands = new Max(continentsWithMountains, continentsWithBadlands_se);
			
			#endregion
			
			#region Continents With Rivers
			
			// Module subgroup: continents with rivers (4 noise modules)
			//
			// This subgroup applies the river-positions group to the continents-with-
			// badlands subgroup.
			//
			// The output value from this module subgroup is measured in planetary
			// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
			// highest mountain peaks.)
			
			// 1: [Scaled-rivers module]: This scale/bias module scales the output value
			//    from the river-positions group so that it is measured in planetary
			//    elevation units and is negative; this is required for step 2.
			ScaleBias continentsWithRivers_sb = new ScaleBias(riverPositions);
			continentsWithRivers_sb.Scale = river_depth/2.0;
			continentsWithRivers_sb.Bias = -river_depth/2.0;
			
			// 2: [Add-rivers-to-continents module]: This addition module adds the
			//    rivers to the continents-with-badlands subgroup.  Because the scaled-
			//    rivers module only outputs a negative value, the scaled-rivers module
			//    carves the rivers out of the terrain.
			Add continentsWithRivers_ad = new Add(continentsWithBadlands, continentsWithRivers_sb);
			
			// 3: [Blended-rivers-to-continents module]: This selector module outputs
			//    deep rivers near sea level and shallower rivers in higher terrain.  It
			//    does this by selecting the output value from the continents-with-
			//    badlands subgroup if the corresponding output value from the
			//    continents-with-badlands subgroup is far from sea level.  Otherwise,
			//    this selector module selects the output value from the add-rivers-to-
			//    continents module.
			Select finalPlanet = new Select(continentsWithBadlands, continentsWithRivers_ad, continentsWithBadlands);
			finalPlanet.SetBounds(sea_level, cont_height_scale + sea_level);
			finalPlanet.FallOff = cont_height_scale - sea_level;
			
			
			_module = finalPlanet;
			#endregion
		}
	}
}

